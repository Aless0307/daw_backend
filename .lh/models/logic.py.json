{
    "sourceFile": "models/logic.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1746139832132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746140052438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,27 +1,53 @@\n # models/logic.py\n-from pydantic import BaseModel\n-from typing import Dict, Optional\n+from pydantic import BaseModel, Field # Importa Field\n+from typing import Dict, Optional, List, Union # Importa List y Union\n+from bson import ObjectId # Importa ObjectId\n \n+# --- Modelos Existentes ---\n # Modelo para el progreso en una dificultad específica\n class DifficultyProgress(BaseModel):\n     solved_count: int = 0\n-    # Usamos Optional[float] si prefieres representar \"sin promedio\" como None,\n-    # o simplemente 0.0 si el conteo es 0. Aquí usaremos 0.0 si conteo es 0.\n     average_grade: float = 0.0\n \n # Modelo principal para la respuesta del progreso general del usuario\n class UserProgressResponse(BaseModel):\n     total_solved: int = 0\n-    # Diccionario donde la clave es la dificultad (\"basico\", \"intermedio\", \"avanzado\")\n     progress_by_difficulty: Dict[str, DifficultyProgress] = {}\n     overall_average_grade: float = 0.0\n-    message: str = \"Progreso cargado exitosamente\" # Mensaje opcional para el frontend\n+    message: str = \"Progreso cargado exitosamente\"\n \n-    # Configuración para Pydantic v2+ (si aplica)\n+    # Para Pydantic v2+ (si aplica)\n     # from pydantic import ConfigDict\n\\ No newline at end of file\n-    # model_config = ConfigDict(populate_by_name=True) # Si necesitas mapear alias\n+    # model_config = ConfigDict(populate_by_name=True)\n \n-    # Para Pydantic v1 o v2 con json_encoders\n-    # class Config:\n-    #     json_encoders = {ObjectId: str} # Aunque aquí no retornamos ObjectIds directamente\n-    #     # allow_population_by_field_name = True # Para Pydantic v1 para mapear alias\n+\n+# --- Nuevos Modelos para la Respuesta del Problema ---\n+\n+# Modelo para un problema individual\n+class ProblemResponse(BaseModel):\n+    # Mapea el campo '_id' de MongoDB (ObjectId) a 'id' en el modelo y JSON\n+    id: str = Field(alias=\"_id\")\n+    text: str\n+    difficulty: str\n+    topics: List[str] = [] # Incluimos topics ya que los insertamos\n+\n+    class Config:\n+        # Permite mapear por alias ('_id' a 'id')\n+        populate_by_name = True\n+        # Configuración para serializar ObjectId a string (para Pydantic v1 y v2)\n+        json_encoders = {ObjectId: str}\n+\n+        # Para Pydantic V2+, también puedes añadir ejemplos (Opcional para docs)\n+        # json_schema_extra = {\n+        #     \"example\": {\n+        #         \"id\": \"60d5ec49b8f9c40e6c1a0d9e\",\n+        #         \"text\": \"¿Cómo invertirías una cadena de texto?\",\n+        #         \"difficulty\": \"basico\",\n+        #         \"topics\": [\"cadenas\", \"inversion\"]\n+        #     }\n+        # }\n+\n+# Modelo para la respuesta cuando no se encuentran problemas sin resolver\n+class NoProblemResponse(BaseModel):\n+    message: str = \"No se encontraron problemas sin resolver para la dificultad especificada.\"\n+    # Puedes añadir campos opcionales si quieres devolver más contexto (ej. requested_difficulty: Optional[str] = None)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746238320006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,5 +49,19 @@\n \n # Modelo para la respuesta cuando no se encuentran problemas sin resolver\n class NoProblemResponse(BaseModel):\n     message: str = \"No se encontraron problemas sin resolver para la dificultad especificada.\"\n-    # Puedes añadir campos opcionales si quieres devolver más contexto (ej. requested_difficulty: Optional[str] = None)\n\\ No newline at end of file\n+    # Puedes añadir campos opcionales si quieres devolver más contexto (ej. requested_difficulty: Optional[str] = None)\n+\n+class FeedbackResponse(BaseModel):\n+    analysis: str\n+    grade: Union[int, float] = Field(..., ge=0, le=5) # Calificación entre 0 y 5\n+\n+    class Config:\n+         orm_mode = True # Opcional, útil si trabajas con ORM\n+         # Ejemplo de datos para documentación Swagger/OpenAPI\n+         schema_extra = {\n+             \"example\": {\n+                 \"analysis\": \"Tu explicación es clara pero podrías detallar más el caso base.\",\n+                 \"grade\": 4\n+             }\n+         }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746282570413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,17 +51,21 @@\n class NoProblemResponse(BaseModel):\n     message: str = \"No se encontraron problemas sin resolver para la dificultad especificada.\"\n     # Puedes añadir campos opcionales si quieres devolver más contexto (ej. requested_difficulty: Optional[str] = None)\n \n+from pydantic import BaseModel, Field\n+from typing import Union\n+\n class FeedbackResponse(BaseModel):\n     analysis: str\n-    grade: Union[int, float] = Field(..., ge=0, le=5) # Calificación entre 0 y 5\n+    # --- RANGO 0-10 ---\n+    grade: Union[int, float] = Field(..., ge=0, le=10) # Permitir hasta 10\n+    # --- FIN AJUSTE ---\n \n     class Config:\n-         orm_mode = True # Opcional, útil si trabajas con ORM\n-         # Ejemplo de datos para documentación Swagger/OpenAPI\n-         schema_extra = {\n+         orm_mode = True # O from_attributes = True en Pydantic v2\n+         schema_extra = { # O model_config = {\"json_schema_extra\": ...} en Pydantic v2\n              \"example\": {\n-                 \"analysis\": \"Tu explicación es clara pero podrías detallar más el caso base.\",\n-                 \"grade\": 4\n+                 \"analysis\": \"Buen intento, considera los casos borde.\",\n+                 \"grade\": 7 # Ejemplo con nota 0-10\n              }\n          }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746282576960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,8 @@\n class NoProblemResponse(BaseModel):\n     message: str = \"No se encontraron problemas sin resolver para la dificultad especificada.\"\n     # Puedes añadir campos opcionales si quieres devolver más contexto (ej. requested_difficulty: Optional[str] = None)\n \n-from pydantic import BaseModel, Field\n-from typing import Union\n-\n class FeedbackResponse(BaseModel):\n     analysis: str\n     # --- RANGO 0-10 ---\n     grade: Union[int, float] = Field(..., ge=0, le=10) # Permitir hasta 10\n"
                },
                {
                    "date": 1746309134081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,5 +64,9 @@\n              \"example\": {\n                  \"analysis\": \"Buen intento, considera los casos borde.\",\n                  \"grade\": 7 # Ejemplo con nota 0-10\n              }\n-         }\n\\ No newline at end of file\n+         }\n+         \n+# --- Nuevo Modelo para el cuerpo de la solicitud TTS ---\n+class TTSTextRequest(BaseModel):\n+    text: str # Esperamos un campo 'text' que sea una cadena\n"
                }
            ],
            "date": 1746139832132,
            "name": "Commit-0",
            "content": "# models/logic.py\nfrom pydantic import BaseModel\nfrom typing import Dict, Optional\n\n# Modelo para el progreso en una dificultad específica\nclass DifficultyProgress(BaseModel):\n    solved_count: int = 0\n    # Usamos Optional[float] si prefieres representar \"sin promedio\" como None,\n    # o simplemente 0.0 si el conteo es 0. Aquí usaremos 0.0 si conteo es 0.\n    average_grade: float = 0.0\n\n# Modelo principal para la respuesta del progreso general del usuario\nclass UserProgressResponse(BaseModel):\n    total_solved: int = 0\n    # Diccionario donde la clave es la dificultad (\"basico\", \"intermedio\", \"avanzado\")\n    progress_by_difficulty: Dict[str, DifficultyProgress] = {}\n    overall_average_grade: float = 0.0\n    message: str = \"Progreso cargado exitosamente\" # Mensaje opcional para el frontend\n\n    # Configuración para Pydantic v2+ (si aplica)\n    # from pydantic import ConfigDict\n    # model_config = ConfigDict(populate_by_name=True) # Si necesitas mapear alias\n\n    # Para Pydantic v1 o v2 con json_encoders\n    # class Config:\n    #     json_encoders = {ObjectId: str} # Aunque aquí no retornamos ObjectIds directamente\n    #     # allow_population_by_field_name = True # Para Pydantic v1 para mapear alias"
        }
    ]
}