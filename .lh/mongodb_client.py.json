{
    "sourceFile": "mongodb_client.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1746139682303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746139705584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+import datetime\n from pymongo import MongoClient\n from pymongo.errors import ServerSelectionTimeoutError\n import logging\n from keys import MONGODB_URI, DATABASE_NAME\n"
                },
                {
                    "date": 1746141331458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,61 +360,81 @@\n         Returns:\n             dict: Un documento de problema (con _id, text, difficulty) o None si no hay problemas sin resolver.\n         \"\"\"\n         try:\n-            logger.info(f\"Buscando problema sin resolver para user_id: {user_id}, dificultad: {difficulty}\")\n+            # --- Añadir Logging de entrada ---\n+            logger.info(f\"[{user_id}] Inicio get_random_unsolved_problem. Dificultad solicitada: {difficulty}\")\n \n             # 1. Obtener los IDs de los problemas que el usuario ya resolvió\n             user_doc = self._db.users.find_one(\n                 {\"_id\": user_id},\n                 {\"ejercicios\": 1} # Solo necesitamos el array de ejercicios resueltos\n             )\n             solved_problem_ids = []\n             if user_doc and user_doc.get(\"ejercicios\"):\n-                # Extraer solo los problem_id del array de ejercicios resueltos\n                 solved_problem_ids = [\n                     exercise[\"problem_id\"]\n                     for exercise in user_doc[\"ejercicios\"]\n-                    if \"problem_id\" in exercise # Asegurarse de que el campo existe\n+                    if isinstance(exercise, dict) and \"problem_id\" in exercise and isinstance(exercise[\"problem_id\"], ObjectId)\n+                    # Asegurarse de que es un dict y tiene un problem_id que es un ObjectId\n                 ]\n-            logger.debug(f\"Problemas resueltos por {user_id}: {len(solved_problem_ids)} IDs\")\n+            # --- Añadir Logging de IDs resueltos ---\n+            logger.debug(f\"[{user_id}] Problemas resueltos encontrados: {len(solved_problem_ids)} IDs\")\n+            if solved_problem_ids:\n+                # Loguear solo algunos IDs si la lista es muy larga\n+                    logger.debug(f\"[{user_id}] Primeros 5 IDs resueltos: {solved_problem_ids[:5]}\")\n \n+\n             # 2. Construir el filtro para la colección de problemas\n             problem_filter = {}\n             if difficulty:\n                 problem_filter[\"difficulty\"] = difficulty\n \n             # Excluir los problemas que ya ha resuelto el usuario\n-            if solved_problem_ids:\n-                 # $nin: not in (excluir IDs que están en la lista solved_problem_ids)\n-                problem_filter[\"_id\"] = {\"$nin\": solved_problem_ids}\n-            logger.debug(f\"Filtro para buscar problemas: {problem_filter}\")\n+            # La condición es: \"_id no debe estar en la lista de solved_problem_ids\"\n+            problem_filter[\"_id\"] = {\"$nin\": solved_problem_ids}\n \n+            # --- Añadir Logging del filtro ---\n+            logger.debug(f\"[{user_id}] Filtro final para la colección 'ejercicios': {problem_filter}\")\n+\n+\n             # 3. Buscar un problema aleatorio que coincida con el filtro\n             # Usar el pipeline de agregación con $sample para obtener un documento aleatorio\n             pipeline = [\n                 {\"$match\": problem_filter},\n                 {\"$sample\": {\"size\": 1}} # Obtener 1 documento aleatorio del resultado del $match\n+                # Opcional: Añadir un $project si quieres limitar los campos devueltos\n+                # {\"$project\": {\"text\": 1, \"difficulty\": 1, \"topics\": 1}}\n             ]\n \n             # Ejecutar la agregación en la colección de problemas (ejercicios)\n             problem_collection = self._db.ejercicios # Asumiendo que la colección de problemas se llama 'ejercicios'\n+\n+            # --- Añadir Logging del pipeline ---\n+            logger.debug(f\"[{user_id}] Pipeline de agregación: {pipeline}\")\n+\n             result = list(problem_collection.aggregate(pipeline))\n \n+            # --- Añadir Logging del resultado de la agregación ---\n+            logger.debug(f\"[{user_id}] Resultado de la agregación: {result}\")\n+\n+\n             if result:\n-                logger.info(f\"Problema sin resolver encontrado para user_id: {user_id}\")\n+                logger.info(f\"[{user_id}] Problema sin resolver encontrado: {result[0].get('_id')} (Dificultad: {result[0].get('difficulty')})\")\n                 # Devolver el primer (y único) documento del resultado de $sample\n                 return result[0]\n             else:\n-                logger.info(f\"No se encontraron problemas sin resolver para user_id: {user_id}, dificultad: {difficulty}\")\n+                # Este es el caso que te está ocurriendo\n+                logger.warning(f\"[{user_id}] No se encontraron problemas sin resolver con el filtro especificado. El resultado de la agregación está vacío.\")\n                 return None # No hay problemas que coincidan con los criterios y no estén resueltos\n \n         except Exception as e:\n-            logger.error(f\"Error al buscar problema sin resolver para user_id {user_id}: {str(e)}\")\n+            # --- Añadir Logging de error ---\n+            logger.error(f\"[{user_id}] ERROR en get_random_unsolved_problem: {str(e)}\", exc_info=True) # exc_info=True para stack trace\n             # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n-            return None\n+            # raise # Si quieres que el error llegue al cliente como 500\n+            return None # Si prefieres que el endpoint retorne None o un mensaje amigable\n \n-\n     def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> bool:\n         \"\"\"\n         Añade un ejercicio resuelto al array 'ejercicios' del usuario.\n \n"
                },
                {
                    "date": 1746240545689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,505 @@\n+import datetime\n+from pymongo import MongoClient\n+from pymongo.errors import ServerSelectionTimeoutError\n+import logging\n+from keys import MONGODB_URI, DATABASE_NAME\n+from typing import Optional\n+from config import VOICE_SIMILARITY_THRESHOLD\n+from bson import ObjectId # Importar ObjectId\n+\n+# Configurar logging\n+logging.basicConfig(\n+    level=logging.INFO,\n+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n+    handlers=[\n+        logging.StreamHandler(),\n+        logging.FileHandler('mongodb_client.log')\n+    ]\n+)\n+logger = logging.getLogger(__name__)\n+\n+class MongoDBClient:\n+    _instance = None\n+    _client = None\n+    _db = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super(MongoDBClient, cls).__new__(cls)\n+            cls._instance._connect()\n+        return cls._instance\n+\n+    def _connect(self):\n+        try:\n+            self._client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n+            self._db = self._client[DATABASE_NAME]\n+            # Verificar la conexión\n+            self._client.server_info()\n+            logger.info(\"Conexión a MongoDB establecida correctamente\")\n+        except ServerSelectionTimeoutError as e:\n+            logger.error(f\"Error al conectar con MongoDB: {str(e)}\")\n+            raise\n+        except Exception as e:\n+            logger.error(f\"Error inesperado al conectar con MongoDB: {str(e)}\")\n+            raise\n+\n+    def get_db(self):\n+        return self._db\n+\n+    def get_collection(self, collection_name):\n+        return self._db[collection_name]\n+\n+    def create_user(self, username: str, email: str, password: str, voice_embedding: list = None, voice_url: str = None, voice_embeddings: list = None, face_url: str = None) -> bool:\n+        \"\"\"\n+        Crea un nuevo usuario en la base de datos\n+        \n+        Args:\n+            username: Nombre del usuario\n+            email: Email del usuario\n+            password: Contraseña hasheada\n+            voice_embedding: Embedding de voz individual (opcional)\n+            voice_url: URL del archivo de voz (opcional)\n+            voice_embeddings: Lista de embeddings de voz (opcional)\n+            face_url: URL de la foto de rostro (opcional)\n+            face_url_view: URL del visor de la foto de rostro (opcional)\n+            \n+        Returns:\n+            bool: True si el usuario fue creado exitosamente\n+        \"\"\"\n+        try:\n+            logger.info(f\"Creando usuario: {email}\")\n+            \n+            # Verificar si el usuario ya existe\n+            if self.get_user_by_email(email):\n+                logger.warning(f\"El usuario con email {email} ya existe\")\n+                return False\n+            \n+            # Preparar datos del usuario\n+            user_data = {\n+                \"username\": username,\n+                \"email\": email,\n+                \"password\": password\n+            }\n+            \n+            # Agregar datos opcionales si existen\n+            if voice_embedding is not None:\n+                user_data[\"voice_embedding\"] = voice_embedding\n+            if voice_embeddings is not None:\n+                user_data[\"voice_embeddings\"] = voice_embeddings\n+            if voice_url is not None:\n+                user_data[\"voice_url\"] = voice_url\n+            if face_url is not None:\n+                user_data[\"face_url\"] = face_url\n+            \n+            # Insertar en la base de datos\n+            result = self._db.users.insert_one(user_data)\n+            \n+            if result.inserted_id:\n+                logger.info(f\"Usuario creado exitosamente: {email}\")\n+                return True\n+            else:\n+                logger.error(f\"Error al crear usuario: {email}\")\n+                return False\n+                \n+        except Exception as e:\n+            logger.error(f\"Error al crear usuario {email}: {str(e)}\")\n+            return False\n+\n+    def get_user_by_email(self, email: str) -> dict:\n+        \"\"\"\n+        Obtiene un usuario por su email\n+        \n+        Args:\n+            email: Email del usuario a buscar\n+            \n+        Returns:\n+            dict: Datos del usuario o None si no existe\n+        \"\"\"\n+        try:\n+            logger.info(f\"Buscando usuario: {email}\")\n+            user = self._db.users.find_one({\"email\": email})\n+            if user:\n+                logger.info(f\"Usuario encontrado: {email}\")\n+                return user\n+            else:\n+                logger.info(f\"Usuario no encontrado: {email}\")\n+                return None\n+        except Exception as e:\n+            logger.error(f\"Error al buscar usuario {email}: {str(e)}\")\n+            return None\n+\n+    def update_user_voice(self, email: str, voice_embedding: list, voice_url: str = None) -> bool:\n+        \"\"\"\n+        Actualiza los datos de voz de un usuario\n+        \n+        Args:\n+            email: Email del usuario\n+            voice_embedding: Nuevo embedding de voz\n+            voice_url: Nueva URL del archivo de voz (opcional)\n+            \n+        Returns:\n+            bool: True si la actualización fue exitosa\n+        \"\"\"\n+        try:\n+            logger.info(f\"Actualizando datos de voz para: {email}\")\n+            \n+            # Preparar datos de actualización\n+            update_data = {\n+                \"voice_embedding\": voice_embedding\n+            }\n+            if voice_url is not None:\n+                update_data[\"voice_url\"] = voice_url\n+            \n+            # Actualizar en la base de datos\n+            result = self._db.users.update_one(\n+                {\"email\": email},\n+                {\"$set\": update_data}\n+            )\n+            \n+            if result.modified_count > 0:\n+                logger.info(f\"Datos de voz actualizados para: {email}\")\n+                return True\n+            else:\n+                logger.warning(f\"No se actualizaron datos de voz para: {email}\")\n+                return False\n+                \n+        except Exception as e:\n+            logger.error(f\"Error al actualizar datos de voz para {email}: {str(e)}\")\n+            return False\n+\n+    def verify_user_credentials(self, email: str, password: str) -> dict:\n+        \"\"\"\n+        Verifica las credenciales de un usuario\n+        \n+        Args:\n+            email: Email del usuario\n+            password: Contraseña hasheada\n+            \n+        Returns:\n+            dict: Datos del usuario si las credenciales son correctas, None en caso contrario\n+        \"\"\"\n+        try:\n+            logger.info(f\"Verificando credenciales para: {email}\")\n+            \n+            # Primero, buscar el usuario por email\n+            user = self._db.users.find_one({\"email\": email})\n+            \n+            if not user:\n+                logger.warning(f\"Usuario no encontrado para el email: {email}\")\n+                return None\n+                \n+            # Verificar la contraseña\n+            if user.get(\"password\") == password:\n+                logger.info(f\"Credenciales válidas para: {email}\")\n+                return user\n+            else:\n+                logger.warning(f\"Contraseña incorrecta para: {email}\")\n+                return None\n+                \n+        except Exception as e:\n+            logger.error(f\"Error al verificar credenciales para {email}: {str(e)}\")\n+            return None\n+\n+    def find_user_by_voice(self, voice_embedding: list) -> Optional[dict]:\n+        \"\"\"\n+        Busca un usuario por su embedding de voz.\n+        \n+        Args:\n+            voice_embedding (list): Embedding de voz a buscar\n+            \n+        Returns:\n+            Optional[dict]: Usuario encontrado o None\n+        \"\"\"\n+        try:\n+            # Importar localmente para evitar importación circular\n+            from voice_processing import compare_voices\n+            \n+            logger.info(\"Buscando usuario por voz\")\n+            \n+            # Obtener todos los usuarios con embedding de voz (antiguo o nuevo formato)\n+            users = list(self._db.users.find({\n+                \"$or\": [\n+                    {\"voice_embedding\": {\"$exists\": True}},\n+                    {\"voice_embeddings\": {\"$exists\": True}}\n+                ]\n+            }))\n+            \n+            best_match = None\n+            best_similarity = 0\n+            \n+            # Comparar con cada usuario\n+            for user in users:\n+                max_similarity = 0\n+                \n+                # Verificar embeddings individuales si existen\n+                if \"voice_embedding\" in user:\n+                    user_embedding = user[\"voice_embedding\"]\n+                    result = compare_voices(user_embedding, voice_embedding)\n+                    similarity = result.get(\"similarity\", 0)\n+                    max_similarity = max(max_similarity, similarity)\n+                \n+                # Verificar galería de embeddings si existe\n+                if \"voice_embeddings\" in user and isinstance(user[\"voice_embeddings\"], list):\n+                    for stored_embedding in user[\"voice_embeddings\"]:\n+                        result = compare_voices(stored_embedding, voice_embedding)\n+                        similarity = result.get(\"similarity\", 0)\n+                        max_similarity = max(max_similarity, similarity)\n+                \n+                # Actualizar mejor coincidencia si es necesario\n+                if max_similarity > best_similarity:\n+                    best_similarity = max_similarity\n+                    best_match = user\n+            \n+            # Verificar si la mejor coincidencia supera el umbral\n+            if best_match and best_similarity >= VOICE_SIMILARITY_THRESHOLD:\n+                logger.info(f\"Usuario encontrado por voz: {best_match['email']} (similitud: {best_similarity:.4f})\")\n+                return best_match\n+            \n+            logger.info(\"No se encontró usuario con esa voz\")\n+            return None\n+            \n+        except Exception as e:\n+            logger.error(f\"Error al buscar usuario por voz: {str(e)}\")\n+            raise\n+\n+    def update_user_voice_gallery(self, email: str, voice_embeddings: list, voice_url: str = None) -> bool:\n+        \"\"\"\n+        Actualiza la galería de embeddings de voz de un usuario\n+        \n+        Args:\n+            email: Email del usuario\n+            voice_embeddings: Lista de embeddings de voz\n+            voice_url: Nueva URL del archivo de voz (opcional)\n+            \n+        Returns:\n+            bool: True si la actualización fue exitosa\n+        \"\"\"\n+        try:\n+            logger.info(f\"Actualizando galería de embeddings de voz para: {email}\")\n+            \n+            # Preparar datos de actualización\n+            update_data = {\n+                \"voice_embeddings\": voice_embeddings\n+            }\n+            if voice_url is not None:\n+                update_data[\"voice_url\"] = voice_url\n+            \n+            # Actualizar en la base de datos\n+            result = self._db.users.update_one(\n+                {\"email\": email},\n+                {\"$set\": update_data}\n+            )\n+            \n+            if result.modified_count > 0:\n+                logger.info(f\"Galería de voz actualizada para: {email} con {len(voice_embeddings)} embeddings\")\n+                return True\n+            else:\n+                logger.warning(f\"No se actualizó la galería de voz para: {email}\")\n+                return False\n+                \n+        except Exception as e:\n+            logger.error(f\"Error al actualizar galería de voz para {email}: {str(e)}\")\n+            return False\n+\n+    def get_user_voice_data(self, email: str) -> dict:\n+        \"\"\"\n+        Obtiene los datos de voz de un usuario\n+        \n+        Args:\n+            email: Email del usuario\n+            \n+        Returns:\n+            dict: Datos de voz del usuario (embeddings y URL) o None si no existen\n+        \"\"\"\n+        try:\n+            logger.info(f\"Obteniendo datos de voz para: {email}\")\n+            \n+            # Buscar usuario\n+            user = self._db.users.find_one(\n+                {\"email\": email},\n+                {\"voice_embedding\": 1, \"voice_embeddings\": 1, \"voice_url\": 1, \"_id\": 0}\n+            )\n+            \n+            if not user:\n+                logger.warning(f\"Usuario no encontrado: {email}\")\n+                return None\n+                \n+            return user\n+                \n+        except Exception as e:\n+            logger.error(f\"Error al obtener datos de voz para {email}: {str(e)}\")\n+            return None \n+        \n+        # Tu get_current_user retorna el dict completo, lo cual es bueno, pero tener get_user_by_id puede ser útil.\n+    def get_user_by_id(self, user_id: ObjectId) -> Optional[dict]:\n+         \"\"\"Obtiene un usuario por su ObjectId.\"\"\"\n+         try:\n+             logger.debug(f\"Buscando usuario por ID: {user_id}\")\n+             user = self._db.users.find_one({\"_id\": user_id})\n+             # No loguear el usuario completo por seguridad\n+             if user:\n+                 logger.debug(f\"Usuario encontrado por ID: {user_id}\")\n+             else:\n+                 logger.debug(f\"Usuario no encontrado por ID: {user_id}\")\n+             return user\n+         except Exception as e:\n+             logger.error(f\"Error al buscar usuario por ID {user_id}: {str(e)}\")\n+             return None\n+\n+\n+    # --- NUEVOS MÉTODOS PARA LA LÓGICA ---\n+\n+    def get_random_unsolved_problem(self, user_id: ObjectId, difficulty: Optional[str] = None) -> Optional[dict]:\n+        \"\"\"\n+        Busca un problema aleatorio que el usuario no haya resuelto, opcionalmente filtrado por dificultad.\n+\n+        Args:\n+            user_id: El ObjectId del usuario.\n+            difficulty: Dificultad del problema a buscar (ej. \"basico\", \"intermedio\", \"avanzado\").\n+\n+        Returns:\n+            dict: Un documento de problema (con _id, text, difficulty) o None si no hay problemas sin resolver.\n+        \"\"\"\n+        try:\n+            # --- Añadir Logging de entrada ---\n+            logger.info(f\"[{user_id}] Inicio get_random_unsolved_problem. Dificultad solicitada: {difficulty}\")\n+\n+            # 1. Obtener los IDs de los problemas que el usuario ya resolvió\n+            user_doc = self._db.users.find_one(\n+                {\"_id\": user_id},\n+                {\"ejercicios\": 1} # Solo necesitamos el array de ejercicios resueltos\n+            )\n+            solved_problem_ids = []\n+            if user_doc and user_doc.get(\"ejercicios\"):\n+                solved_problem_ids = [\n+                    exercise[\"problem_id\"]\n+                    for exercise in user_doc[\"ejercicios\"]\n+                    if isinstance(exercise, dict) and \"problem_id\" in exercise and isinstance(exercise[\"problem_id\"], ObjectId)\n+                    # Asegurarse de que es un dict y tiene un problem_id que es un ObjectId\n+                ]\n+            # --- Añadir Logging de IDs resueltos ---\n+            logger.debug(f\"[{user_id}] Problemas resueltos encontrados: {len(solved_problem_ids)} IDs\")\n+            if solved_problem_ids:\n+                # Loguear solo algunos IDs si la lista es muy larga\n+                    logger.debug(f\"[{user_id}] Primeros 5 IDs resueltos: {solved_problem_ids[:5]}\")\n+\n+\n+            # 2. Construir el filtro para la colección de problemas\n+            problem_filter = {}\n+            if difficulty:\n+                problem_filter[\"difficulty\"] = difficulty\n+\n+            # Excluir los problemas que ya ha resuelto el usuario\n+            # La condición es: \"_id no debe estar en la lista de solved_problem_ids\"\n+            problem_filter[\"_id\"] = {\"$nin\": solved_problem_ids}\n+\n+            # --- Añadir Logging del filtro ---\n+            logger.debug(f\"[{user_id}] Filtro final para la colección 'ejercicios': {problem_filter}\")\n+\n+\n+            # 3. Buscar un problema aleatorio que coincida con el filtro\n+            # Usar el pipeline de agregación con $sample para obtener un documento aleatorio\n+            pipeline = [\n+                {\"$match\": problem_filter},\n+                {\"$sample\": {\"size\": 1}} # Obtener 1 documento aleatorio del resultado del $match\n+                # Opcional: Añadir un $project si quieres limitar los campos devueltos\n+                # {\"$project\": {\"text\": 1, \"difficulty\": 1, \"topics\": 1}}\n+            ]\n+\n+            # Ejecutar la agregación en la colección de problemas (ejercicios)\n+            problem_collection = self._db.ejercicios # Asumiendo que la colección de problemas se llama 'ejercicios'\n+\n+            # --- Añadir Logging del pipeline ---\n+            logger.debug(f\"[{user_id}] Pipeline de agregación: {pipeline}\")\n+\n+            result = list(problem_collection.aggregate(pipeline))\n+\n+            # --- Añadir Logging del resultado de la agregación ---\n+            logger.debug(f\"[{user_id}] Resultado de la agregación: {result}\")\n+\n+\n+            if result:\n+                logger.info(f\"[{user_id}] Problema sin resolver encontrado: {result[0].get('_id')} (Dificultad: {result[0].get('difficulty')})\")\n+                # Devolver el primer (y único) documento del resultado de $sample\n+                return result[0]\n+            else:\n+                # Este es el caso que te está ocurriendo\n+                logger.warning(f\"[{user_id}] No se encontraron problemas sin resolver con el filtro especificado. El resultado de la agregación está vacío.\")\n+                return None # No hay problemas que coincidan con los criterios y no estén resueltos\n+\n+        except Exception as e:\n+            # --- Añadir Logging de error ---\n+            logger.error(f\"[{user_id}] ERROR en get_random_unsolved_problem: {str(e)}\", exc_info=True) # exc_info=True para stack trace\n+            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n+            # raise # Si quieres que el error llegue al cliente como 500\n+            return None # Si prefieres que el endpoint retorne None o un mensaje amigable\n+\n+    def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> bool:\n+        \"\"\"\n+        Añade un ejercicio resuelto al array 'ejercicios' del usuario.\n+\n+        Args:\n+            user_id: El ObjectId del usuario.\n+            exercise_data: Diccionario con los datos del ejercicio resuelto\n+                           (problem_id, problem_difficulty, user_answer, llm_analysis, llm_grade, timestamp).\n+\n+        Returns:\n+            bool: True si la inserción fue exitosa (modified_count > 0).\n+        \"\"\"\n+        try:\n+            logger.info(f\"Añadiendo ejercicio resuelto para user_id: {user_id}\")\n+            # Asegúrate de que exercise_data contiene problem_id (ObjectId) y problem_difficulty\n+            if not isinstance(exercise_data.get(\"problem_id\"), ObjectId):\n+                 logger.error(f\"exercise_data debe contener 'problem_id' de tipo ObjectId. Recibido: {type(exercise_data.get('problem_id'))}\")\n+                 return False\n+            if not exercise_data.get(\"problem_difficulty\"):\n+                 logger.error(\"exercise_data debe contener 'problem_difficulty'.\")\n+                 return False\n+            # timestamp debe ser un objeto datetime o similar si quieres guardarlo como ISODate\n+            if not isinstance(exercise_data.get(\"timestamp\"), (datetime, type(None))): # Permitir None si lo generas después\n+                 logger.warning(f\"'timestamp' en exercise_data no es un objeto datetime: {type(exercise_data.get('timestamp'))}. Se espera datetime.\")\n+\n+\n+            # Usar $push para añadir el nuevo documento al array 'ejercicios'\n+            result = self._db.users.update_one(\n+                {\"_id\": user_id},\n+                {\"$push\": {\"ejercicios\": exercise_data}}\n+            )\n+\n+            if result.modified_count > 0:\n+                logger.info(f\"Ejercicio resuelto añadido para user_id: {user_id}\")\n+                return True\n+            else:\n+                logger.warning(f\"No se modificó el documento del usuario {user_id} al añadir ejercicio resuelto. Usuario no encontrado o error.\")\n+                # Podría indicar que el usuario no existe\n+                return False\n+\n+        except Exception as e:\n+            logger.error(f\"Error al añadir ejercicio resuelto para user_id {user_id}: {str(e)}\")\n+            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n+            return False\n+        \n+    # Dentro de la clase MongoDBClient en mongodb_client.py\n+\n+    # --- MÉTODO QUE FALTA ---\n+    def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n+        \"\"\"Busca un problema por su ObjectId en la colección de problemas.\"\"\"\n+        # Asegúrate de que 'self.problems_collection' sea el nombre correcto\n+        # de tu variable de instancia para la colección de problemas.\n+        if not hasattr(self, 'problems_collection') or self.problems_collection is None:\n+             logger.error(\"MongoDBClient: La colección 'problems_collection' no está inicializada.\")\n+             return None\n+        logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id}\") # Log para depuración\n+        try:\n+            problem = self.problems_collection.find_one({\"_id\": problem_id})\n+            if problem:\n+                 logger.info(f\"MONGO_CLIENT: Problema encontrado para ID {problem_id}\")\n+            else:\n+                 logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en la colección.\")\n+            return problem # Devuelve el documento (dict) o None\n+        except Exception as e:\n+             logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id}: {e}\", exc_info=True)\n+             return None # Devuelve None en caso de error de DB\n+    # --- FIN DEL MÉTODO A AÑADIR ---\n+\n+# ... (resto de los métodos de tu clase MongoDBClient) ...\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746240767898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -485,14 +485,14 @@\n     def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n         \"\"\"Busca un problema por su ObjectId en la colección de problemas.\"\"\"\n         # Asegúrate de que 'self.problems_collection' sea el nombre correcto\n         # de tu variable de instancia para la colección de problemas.\n-        if not hasattr(self, 'problems_collection') or self.problems_collection is None:\n+        if not hasattr(self, 'ejercicios') or self.ejercicios is None:\n              logger.error(\"MongoDBClient: La colección 'problems_collection' no está inicializada.\")\n              return None\n         logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id}\") # Log para depuración\n         try:\n-            problem = self.problems_collection.find_one({\"_id\": problem_id})\n+            problem = self.ejercicios.find_one({\"_id\": problem_id})\n             if problem:\n                  logger.info(f\"MONGO_CLIENT: Problema encontrado para ID {problem_id}\")\n             else:\n                  logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en la colección.\")\n@@ -501,485 +501,5 @@\n              logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id}: {e}\", exc_info=True)\n              return None # Devuelve None en caso de error de DB\n     # --- FIN DEL MÉTODO A AÑADIR ---\n \n-# ... (resto de los métodos de tu clase MongoDBClient) ...\n-import datetime\n-from pymongo import MongoClient\n-from pymongo.errors import ServerSelectionTimeoutError\n-import logging\n-from keys import MONGODB_URI, DATABASE_NAME\n-from typing import Optional\n-from config import VOICE_SIMILARITY_THRESHOLD\n-from bson import ObjectId # Importar ObjectId\n-\n-# Configurar logging\n-logging.basicConfig(\n-    level=logging.INFO,\n-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n-    handlers=[\n-        logging.StreamHandler(),\n-        logging.FileHandler('mongodb_client.log')\n-    ]\n-)\n-logger = logging.getLogger(__name__)\n-\n-class MongoDBClient:\n-    _instance = None\n-    _client = None\n-    _db = None\n-\n-    def __new__(cls):\n-        if cls._instance is None:\n-            cls._instance = super(MongoDBClient, cls).__new__(cls)\n-            cls._instance._connect()\n-        return cls._instance\n-\n-    def _connect(self):\n-        try:\n-            self._client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n-            self._db = self._client[DATABASE_NAME]\n-            # Verificar la conexión\n-            self._client.server_info()\n-            logger.info(\"Conexión a MongoDB establecida correctamente\")\n-        except ServerSelectionTimeoutError as e:\n-            logger.error(f\"Error al conectar con MongoDB: {str(e)}\")\n-            raise\n-        except Exception as e:\n-            logger.error(f\"Error inesperado al conectar con MongoDB: {str(e)}\")\n-            raise\n-\n-    def get_db(self):\n-        return self._db\n-\n-    def get_collection(self, collection_name):\n-        return self._db[collection_name]\n-\n-    def create_user(self, username: str, email: str, password: str, voice_embedding: list = None, voice_url: str = None, voice_embeddings: list = None, face_url: str = None) -> bool:\n-        \"\"\"\n-        Crea un nuevo usuario en la base de datos\n-        \n-        Args:\n-            username: Nombre del usuario\n-            email: Email del usuario\n-            password: Contraseña hasheada\n-            voice_embedding: Embedding de voz individual (opcional)\n-            voice_url: URL del archivo de voz (opcional)\n-            voice_embeddings: Lista de embeddings de voz (opcional)\n-            face_url: URL de la foto de rostro (opcional)\n-            face_url_view: URL del visor de la foto de rostro (opcional)\n-            \n-        Returns:\n-            bool: True si el usuario fue creado exitosamente\n-        \"\"\"\n-        try:\n-            logger.info(f\"Creando usuario: {email}\")\n-            \n-            # Verificar si el usuario ya existe\n-            if self.get_user_by_email(email):\n-                logger.warning(f\"El usuario con email {email} ya existe\")\n-                return False\n-            \n-            # Preparar datos del usuario\n-            user_data = {\n-                \"username\": username,\n-                \"email\": email,\n-                \"password\": password\n-            }\n-            \n-            # Agregar datos opcionales si existen\n-            if voice_embedding is not None:\n-                user_data[\"voice_embedding\"] = voice_embedding\n-            if voice_embeddings is not None:\n-                user_data[\"voice_embeddings\"] = voice_embeddings\n-            if voice_url is not None:\n-                user_data[\"voice_url\"] = voice_url\n-            if face_url is not None:\n-                user_data[\"face_url\"] = face_url\n-            \n-            # Insertar en la base de datos\n-            result = self._db.users.insert_one(user_data)\n-            \n-            if result.inserted_id:\n-                logger.info(f\"Usuario creado exitosamente: {email}\")\n-                return True\n-            else:\n-                logger.error(f\"Error al crear usuario: {email}\")\n-                return False\n-                \n-        except Exception as e:\n-            logger.error(f\"Error al crear usuario {email}: {str(e)}\")\n-            return False\n-\n-    def get_user_by_email(self, email: str) -> dict:\n-        \"\"\"\n-        Obtiene un usuario por su email\n-        \n-        Args:\n-            email: Email del usuario a buscar\n-            \n-        Returns:\n-            dict: Datos del usuario o None si no existe\n-        \"\"\"\n-        try:\n-            logger.info(f\"Buscando usuario: {email}\")\n-            user = self._db.users.find_one({\"email\": email})\n-            if user:\n-                logger.info(f\"Usuario encontrado: {email}\")\n-                return user\n-            else:\n-                logger.info(f\"Usuario no encontrado: {email}\")\n-                return None\n-        except Exception as e:\n-            logger.error(f\"Error al buscar usuario {email}: {str(e)}\")\n-            return None\n-\n-    def update_user_voice(self, email: str, voice_embedding: list, voice_url: str = None) -> bool:\n-        \"\"\"\n-        Actualiza los datos de voz de un usuario\n-        \n-        Args:\n-            email: Email del usuario\n-            voice_embedding: Nuevo embedding de voz\n-            voice_url: Nueva URL del archivo de voz (opcional)\n-            \n-        Returns:\n-            bool: True si la actualización fue exitosa\n-        \"\"\"\n-        try:\n-            logger.info(f\"Actualizando datos de voz para: {email}\")\n-            \n-            # Preparar datos de actualización\n-            update_data = {\n-                \"voice_embedding\": voice_embedding\n-            }\n-            if voice_url is not None:\n-                update_data[\"voice_url\"] = voice_url\n-            \n-            # Actualizar en la base de datos\n-            result = self._db.users.update_one(\n-                {\"email\": email},\n-                {\"$set\": update_data}\n-            )\n-            \n-            if result.modified_count > 0:\n-                logger.info(f\"Datos de voz actualizados para: {email}\")\n-                return True\n-            else:\n-                logger.warning(f\"No se actualizaron datos de voz para: {email}\")\n-                return False\n-                \n-        except Exception as e:\n-            logger.error(f\"Error al actualizar datos de voz para {email}: {str(e)}\")\n-            return False\n-\n-    def verify_user_credentials(self, email: str, password: str) -> dict:\n-        \"\"\"\n-        Verifica las credenciales de un usuario\n-        \n-        Args:\n-            email: Email del usuario\n-            password: Contraseña hasheada\n-            \n-        Returns:\n-            dict: Datos del usuario si las credenciales son correctas, None en caso contrario\n-        \"\"\"\n-        try:\n-            logger.info(f\"Verificando credenciales para: {email}\")\n-            \n-            # Primero, buscar el usuario por email\n-            user = self._db.users.find_one({\"email\": email})\n-            \n-            if not user:\n-                logger.warning(f\"Usuario no encontrado para el email: {email}\")\n-                return None\n-                \n-            # Verificar la contraseña\n-            if user.get(\"password\") == password:\n-                logger.info(f\"Credenciales válidas para: {email}\")\n-                return user\n-            else:\n-                logger.warning(f\"Contraseña incorrecta para: {email}\")\n-                return None\n-                \n-        except Exception as e:\n-            logger.error(f\"Error al verificar credenciales para {email}: {str(e)}\")\n-            return None\n-\n-    def find_user_by_voice(self, voice_embedding: list) -> Optional[dict]:\n-        \"\"\"\n-        Busca un usuario por su embedding de voz.\n-        \n-        Args:\n-            voice_embedding (list): Embedding de voz a buscar\n-            \n-        Returns:\n-            Optional[dict]: Usuario encontrado o None\n-        \"\"\"\n-        try:\n-            # Importar localmente para evitar importación circular\n-            from voice_processing import compare_voices\n-            \n-            logger.info(\"Buscando usuario por voz\")\n-            \n-            # Obtener todos los usuarios con embedding de voz (antiguo o nuevo formato)\n-            users = list(self._db.users.find({\n-                \"$or\": [\n-                    {\"voice_embedding\": {\"$exists\": True}},\n-                    {\"voice_embeddings\": {\"$exists\": True}}\n-                ]\n-            }))\n-            \n-            best_match = None\n-            best_similarity = 0\n-            \n-            # Comparar con cada usuario\n-            for user in users:\n-                max_similarity = 0\n-                \n-                # Verificar embeddings individuales si existen\n-                if \"voice_embedding\" in user:\n-                    user_embedding = user[\"voice_embedding\"]\n-                    result = compare_voices(user_embedding, voice_embedding)\n-                    similarity = result.get(\"similarity\", 0)\n-                    max_similarity = max(max_similarity, similarity)\n-                \n-                # Verificar galería de embeddings si existe\n-                if \"voice_embeddings\" in user and isinstance(user[\"voice_embeddings\"], list):\n-                    for stored_embedding in user[\"voice_embeddings\"]:\n-                        result = compare_voices(stored_embedding, voice_embedding)\n-                        similarity = result.get(\"similarity\", 0)\n-                        max_similarity = max(max_similarity, similarity)\n-                \n-                # Actualizar mejor coincidencia si es necesario\n-                if max_similarity > best_similarity:\n-                    best_similarity = max_similarity\n-                    best_match = user\n-            \n-            # Verificar si la mejor coincidencia supera el umbral\n-            if best_match and best_similarity >= VOICE_SIMILARITY_THRESHOLD:\n-                logger.info(f\"Usuario encontrado por voz: {best_match['email']} (similitud: {best_similarity:.4f})\")\n-                return best_match\n-            \n-            logger.info(\"No se encontró usuario con esa voz\")\n-            return None\n-            \n-        except Exception as e:\n-            logger.error(f\"Error al buscar usuario por voz: {str(e)}\")\n-            raise\n-\n-    def update_user_voice_gallery(self, email: str, voice_embeddings: list, voice_url: str = None) -> bool:\n-        \"\"\"\n-        Actualiza la galería de embeddings de voz de un usuario\n-        \n-        Args:\n-            email: Email del usuario\n-            voice_embeddings: Lista de embeddings de voz\n-            voice_url: Nueva URL del archivo de voz (opcional)\n-            \n-        Returns:\n-            bool: True si la actualización fue exitosa\n-        \"\"\"\n-        try:\n-            logger.info(f\"Actualizando galería de embeddings de voz para: {email}\")\n-            \n-            # Preparar datos de actualización\n-            update_data = {\n-                \"voice_embeddings\": voice_embeddings\n-            }\n-            if voice_url is not None:\n-                update_data[\"voice_url\"] = voice_url\n-            \n-            # Actualizar en la base de datos\n-            result = self._db.users.update_one(\n-                {\"email\": email},\n-                {\"$set\": update_data}\n-            )\n-            \n-            if result.modified_count > 0:\n-                logger.info(f\"Galería de voz actualizada para: {email} con {len(voice_embeddings)} embeddings\")\n-                return True\n-            else:\n-                logger.warning(f\"No se actualizó la galería de voz para: {email}\")\n-                return False\n-                \n-        except Exception as e:\n-            logger.error(f\"Error al actualizar galería de voz para {email}: {str(e)}\")\n-            return False\n-\n-    def get_user_voice_data(self, email: str) -> dict:\n-        \"\"\"\n-        Obtiene los datos de voz de un usuario\n-        \n-        Args:\n-            email: Email del usuario\n-            \n-        Returns:\n-            dict: Datos de voz del usuario (embeddings y URL) o None si no existen\n-        \"\"\"\n-        try:\n-            logger.info(f\"Obteniendo datos de voz para: {email}\")\n-            \n-            # Buscar usuario\n-            user = self._db.users.find_one(\n-                {\"email\": email},\n-                {\"voice_embedding\": 1, \"voice_embeddings\": 1, \"voice_url\": 1, \"_id\": 0}\n-            )\n-            \n-            if not user:\n-                logger.warning(f\"Usuario no encontrado: {email}\")\n-                return None\n-                \n-            return user\n-                \n-        except Exception as e:\n-            logger.error(f\"Error al obtener datos de voz para {email}: {str(e)}\")\n-            return None \n-        \n-        # Tu get_current_user retorna el dict completo, lo cual es bueno, pero tener get_user_by_id puede ser útil.\n-    def get_user_by_id(self, user_id: ObjectId) -> Optional[dict]:\n-         \"\"\"Obtiene un usuario por su ObjectId.\"\"\"\n-         try:\n-             logger.debug(f\"Buscando usuario por ID: {user_id}\")\n-             user = self._db.users.find_one({\"_id\": user_id})\n-             # No loguear el usuario completo por seguridad\n-             if user:\n-                 logger.debug(f\"Usuario encontrado por ID: {user_id}\")\n-             else:\n-                 logger.debug(f\"Usuario no encontrado por ID: {user_id}\")\n-             return user\n-         except Exception as e:\n-             logger.error(f\"Error al buscar usuario por ID {user_id}: {str(e)}\")\n-             return None\n-\n-\n-    # --- NUEVOS MÉTODOS PARA LA LÓGICA ---\n-\n-    def get_random_unsolved_problem(self, user_id: ObjectId, difficulty: Optional[str] = None) -> Optional[dict]:\n-        \"\"\"\n-        Busca un problema aleatorio que el usuario no haya resuelto, opcionalmente filtrado por dificultad.\n-\n-        Args:\n-            user_id: El ObjectId del usuario.\n-            difficulty: Dificultad del problema a buscar (ej. \"basico\", \"intermedio\", \"avanzado\").\n-\n-        Returns:\n-            dict: Un documento de problema (con _id, text, difficulty) o None si no hay problemas sin resolver.\n-        \"\"\"\n-        try:\n-            # --- Añadir Logging de entrada ---\n-            logger.info(f\"[{user_id}] Inicio get_random_unsolved_problem. Dificultad solicitada: {difficulty}\")\n-\n-            # 1. Obtener los IDs de los problemas que el usuario ya resolvió\n-            user_doc = self._db.users.find_one(\n-                {\"_id\": user_id},\n-                {\"ejercicios\": 1} # Solo necesitamos el array de ejercicios resueltos\n-            )\n-            solved_problem_ids = []\n-            if user_doc and user_doc.get(\"ejercicios\"):\n-                solved_problem_ids = [\n-                    exercise[\"problem_id\"]\n-                    for exercise in user_doc[\"ejercicios\"]\n-                    if isinstance(exercise, dict) and \"problem_id\" in exercise and isinstance(exercise[\"problem_id\"], ObjectId)\n-                    # Asegurarse de que es un dict y tiene un problem_id que es un ObjectId\n-                ]\n-            # --- Añadir Logging de IDs resueltos ---\n-            logger.debug(f\"[{user_id}] Problemas resueltos encontrados: {len(solved_problem_ids)} IDs\")\n-            if solved_problem_ids:\n-                # Loguear solo algunos IDs si la lista es muy larga\n-                    logger.debug(f\"[{user_id}] Primeros 5 IDs resueltos: {solved_problem_ids[:5]}\")\n-\n-\n-            # 2. Construir el filtro para la colección de problemas\n-            problem_filter = {}\n-            if difficulty:\n-                problem_filter[\"difficulty\"] = difficulty\n-\n-            # Excluir los problemas que ya ha resuelto el usuario\n-            # La condición es: \"_id no debe estar en la lista de solved_problem_ids\"\n-            problem_filter[\"_id\"] = {\"$nin\": solved_problem_ids}\n-\n-            # --- Añadir Logging del filtro ---\n-            logger.debug(f\"[{user_id}] Filtro final para la colección 'ejercicios': {problem_filter}\")\n-\n-\n-            # 3. Buscar un problema aleatorio que coincida con el filtro\n-            # Usar el pipeline de agregación con $sample para obtener un documento aleatorio\n-            pipeline = [\n-                {\"$match\": problem_filter},\n-                {\"$sample\": {\"size\": 1}} # Obtener 1 documento aleatorio del resultado del $match\n-                # Opcional: Añadir un $project si quieres limitar los campos devueltos\n-                # {\"$project\": {\"text\": 1, \"difficulty\": 1, \"topics\": 1}}\n-            ]\n-\n-            # Ejecutar la agregación en la colección de problemas (ejercicios)\n-            problem_collection = self._db.ejercicios # Asumiendo que la colección de problemas se llama 'ejercicios'\n-\n-            # --- Añadir Logging del pipeline ---\n-            logger.debug(f\"[{user_id}] Pipeline de agregación: {pipeline}\")\n-\n-            result = list(problem_collection.aggregate(pipeline))\n-\n-            # --- Añadir Logging del resultado de la agregación ---\n-            logger.debug(f\"[{user_id}] Resultado de la agregación: {result}\")\n-\n-\n-            if result:\n-                logger.info(f\"[{user_id}] Problema sin resolver encontrado: {result[0].get('_id')} (Dificultad: {result[0].get('difficulty')})\")\n-                # Devolver el primer (y único) documento del resultado de $sample\n-                return result[0]\n-            else:\n-                # Este es el caso que te está ocurriendo\n-                logger.warning(f\"[{user_id}] No se encontraron problemas sin resolver con el filtro especificado. El resultado de la agregación está vacío.\")\n-                return None # No hay problemas que coincidan con los criterios y no estén resueltos\n-\n-        except Exception as e:\n-            # --- Añadir Logging de error ---\n-            logger.error(f\"[{user_id}] ERROR en get_random_unsolved_problem: {str(e)}\", exc_info=True) # exc_info=True para stack trace\n-            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n-            # raise # Si quieres que el error llegue al cliente como 500\n-            return None # Si prefieres que el endpoint retorne None o un mensaje amigable\n-\n-    def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> bool:\n-        \"\"\"\n-        Añade un ejercicio resuelto al array 'ejercicios' del usuario.\n-\n-        Args:\n-            user_id: El ObjectId del usuario.\n-            exercise_data: Diccionario con los datos del ejercicio resuelto\n-                           (problem_id, problem_difficulty, user_answer, llm_analysis, llm_grade, timestamp).\n-\n-        Returns:\n-            bool: True si la inserción fue exitosa (modified_count > 0).\n-        \"\"\"\n-        try:\n-            logger.info(f\"Añadiendo ejercicio resuelto para user_id: {user_id}\")\n-            # Asegúrate de que exercise_data contiene problem_id (ObjectId) y problem_difficulty\n-            if not isinstance(exercise_data.get(\"problem_id\"), ObjectId):\n-                 logger.error(f\"exercise_data debe contener 'problem_id' de tipo ObjectId. Recibido: {type(exercise_data.get('problem_id'))}\")\n-                 return False\n-            if not exercise_data.get(\"problem_difficulty\"):\n-                 logger.error(\"exercise_data debe contener 'problem_difficulty'.\")\n-                 return False\n-            # timestamp debe ser un objeto datetime o similar si quieres guardarlo como ISODate\n-            if not isinstance(exercise_data.get(\"timestamp\"), (datetime, type(None))): # Permitir None si lo generas después\n-                 logger.warning(f\"'timestamp' en exercise_data no es un objeto datetime: {type(exercise_data.get('timestamp'))}. Se espera datetime.\")\n-\n-\n-            # Usar $push para añadir el nuevo documento al array 'ejercicios'\n-            result = self._db.users.update_one(\n-                {\"_id\": user_id},\n-                {\"$push\": {\"ejercicios\": exercise_data}}\n-            )\n-\n-            if result.modified_count > 0:\n-                logger.info(f\"Ejercicio resuelto añadido para user_id: {user_id}\")\n-                return True\n-            else:\n-                logger.warning(f\"No se modificó el documento del usuario {user_id} al añadir ejercicio resuelto. Usuario no encontrado o error.\")\n-                # Podría indicar que el usuario no existe\n-                return False\n-\n-        except Exception as e:\n-            logger.error(f\"Error al añadir ejercicio resuelto para user_id {user_id}: {str(e)}\")\n-            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n-            return False\n\\ No newline at end of file\n+# ... (resto de los métodos de tu clase MongoDBClient) ...\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746240775709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -486,9 +486,9 @@\n         \"\"\"Busca un problema por su ObjectId en la colección de problemas.\"\"\"\n         # Asegúrate de que 'self.problems_collection' sea el nombre correcto\n         # de tu variable de instancia para la colección de problemas.\n         if not hasattr(self, 'ejercicios') or self.ejercicios is None:\n-             logger.error(\"MongoDBClient: La colección 'problems_collection' no está inicializada.\")\n+             logger.error(\"MongoDBClient: La colección 'ejercicios' no está inicializada.\")\n              return None\n         logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id}\") # Log para depuración\n         try:\n             problem = self.ejercicios.find_one({\"_id\": problem_id})\n"
                },
                {
                    "date": 1746241233056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n class MongoDBClient:\n     _instance = None\n     _client = None\n     _db = None\n-\n+    \n     def __new__(cls):\n         if cls._instance is None:\n             cls._instance = super(MongoDBClient, cls).__new__(cls)\n             cls._instance._connect()\n@@ -479,27 +479,26 @@\n             # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n             return False\n         \n     # Dentro de la clase MongoDBClient en mongodb_client.py\n+    def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n+        \"\"\"Busca un problema por su ObjectId usando self.ejercicios como la colección.\"\"\"\n \n-    # --- MÉTODO QUE FALTA ---\n-    def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n-        \"\"\"Busca un problema por su ObjectId en la colección de problemas.\"\"\"\n-        # Asegúrate de que 'self.problems_collection' sea el nombre correcto\n-        # de tu variable de instancia para la colección de problemas.\n+        # Verificar si el atributo self.ejercicios existe y está inicializado\n         if not hasattr(self, 'ejercicios') or self.ejercicios is None:\n-             logger.error(\"MongoDBClient: La colección 'ejercicios' no está inicializada.\")\n+             logger.error(\"MongoDBClient: El atributo 'self.ejercicios' no existe o no está inicializado. Asegúrate de que __init__ lo define correctamente (ej: self.ejercicios = self.db['ejercicios']).\")\n              return None\n-        logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id}\") # Log para depuración\n+\n+        logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id} en la colección referenciada por self.ejercicios\")\n         try:\n+            # Usar self.ejercicios directamente para la consulta\n             problem = self.ejercicios.find_one({\"_id\": problem_id})\n+\n             if problem:\n                  logger.info(f\"MONGO_CLIENT: Problema encontrado para ID {problem_id}\")\n             else:\n\\ No newline at end of file\n-                 logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en la colección.\")\n-            return problem # Devuelve el documento (dict) o None\n+                 logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en self.ejercicios.\")\n+            return problem\n         except Exception as e:\n-             logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id}: {e}\", exc_info=True)\n-             return None # Devuelve None en caso de error de DB\n-    # --- FIN DEL MÉTODO A AÑADIR ---\n-\n-# ... (resto de los métodos de tu clase MongoDBClient) ...\n+             # Capturar otros posibles errores (ej. error de conexión, etc.)\n+             logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id} usando self.ejercicios: {e}\", exc_info=True)\n+             return None\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746241460080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -478,27 +478,29 @@\n             logger.error(f\"Error al añadir ejercicio resuelto para user_id {user_id}: {str(e)}\")\n             # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n             return False\n         \n-    # Dentro de la clase MongoDBClient en mongodb_client.py\n+# DENTRO de la clase MongoDBClient en mongodb_client.py\n+\n     def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n-        \"\"\"Busca un problema por su ObjectId usando self.ejercicios como la colección.\"\"\"\n-\n-        # Verificar si el atributo self.ejercicios existe y está inicializado\n-        if not hasattr(self, 'ejercicios') or self.ejercicios is None:\n-             logger.error(\"MongoDBClient: El atributo 'self.ejercicios' no existe o no está inicializado. Asegúrate de que __init__ lo define correctamente (ej: self.ejercicios = self.db['ejercicios']).\")\n+        \"\"\"Busca un problema por su ObjectId en la colección 'ejercicios'.\"\"\"\n+        # Acceder a la colección a través de self._db\n+        collection_name = 'ejercicios' # Nombre de la colección de problemas\n+        if self._db is None:\n+             logger.error(f\"MongoDBClient: La conexión a la base de datos (self._db) no está disponible al buscar problema {problem_id}.\")\n              return None\n \n-        logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id} en la colección referenciada por self.ejercicios\")\n+        logger.info(f\"MONGO_CLIENT: Buscando problema con _id: {problem_id} en colección '{collection_name}'\")\n         try:\n-            # Usar self.ejercicios directamente para la consulta\n-            problem = self.ejercicios.find_one({\"_id\": problem_id})\n+            # --- CORRECCIÓN: Usar self._db['nombre_coleccion'] ---\n+            problem_collection = self._db[collection_name]\n\\ No newline at end of file\n+            problem = problem_collection.find_one({\"_id\": problem_id})\n+            # --- FIN CORRECCIÓN ---\n \n             if problem:\n                  logger.info(f\"MONGO_CLIENT: Problema encontrado para ID {problem_id}\")\n             else:\n-                 logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en self.ejercicios.\")\n-            return problem\n+                 logger.warning(f\"MONGO_CLIENT: Problema con _id {problem_id} no encontrado en la colección '{collection_name}'.\")\n+            return problem # Devuelve el documento (dict) o None\n         except Exception as e:\n-             # Capturar otros posibles errores (ej. error de conexión, etc.)\n-             logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id} usando self.ejercicios: {e}\", exc_info=True)\n-             return None\n+             logger.error(f\"MONGO_CLIENT: Error en get_problem_by_id buscando ID {problem_id}: {e}\", exc_info=True)\n+             return None # Devuelve None en caso de error de DB\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746378335641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n         return cls._instance\n \n     def _connect(self):\n         try:\n-            self._client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n+            self._client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=15000) #lo aumento para el wifi del houtel\n             self._db = self._client[DATABASE_NAME]\n             # Verificar la conexión\n             self._client.server_info()\n             logger.info(\"Conexión a MongoDB establecida correctamente\")\n@@ -433,54 +433,45 @@\n             # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n             # raise # Si quieres que el error llegue al cliente como 500\n             return None # Si prefieres que el endpoint retorne None o un mensaje amigable\n \n-    def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> bool:\n+    def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> Optional[object]: # Cambiado tipo de retorno\n         \"\"\"\n         Añade un ejercicio resuelto al array 'ejercicios' del usuario.\n-\n-        Args:\n-            user_id: El ObjectId del usuario.\n-            exercise_data: Diccionario con los datos del ejercicio resuelto\n-                           (problem_id, problem_difficulty, user_answer, llm_analysis, llm_grade, timestamp).\n-\n-        Returns:\n-            bool: True si la inserción fue exitosa (modified_count > 0).\n+        Devuelve el objeto UpdateResult de pymongo o None en caso de error.\n         \"\"\"\n         try:\n             logger.info(f\"Añadiendo ejercicio resuelto para user_id: {user_id}\")\n-            # Asegúrate de que exercise_data contiene problem_id (ObjectId) y problem_difficulty\n             if not isinstance(exercise_data.get(\"problem_id\"), ObjectId):\n-                 logger.error(f\"exercise_data debe contener 'problem_id' de tipo ObjectId. Recibido: {type(exercise_data.get('problem_id'))}\")\n-                 return False\n+                 logger.error(f\"exercise_data: 'problem_id' debe ser ObjectId.\")\n+                 return None # Devolver None en error de validación\n             if not exercise_data.get(\"problem_difficulty\"):\n-                 logger.error(\"exercise_data debe contener 'problem_difficulty'.\")\n-                 return False\n-            # timestamp debe ser un objeto datetime o similar si quieres guardarlo como ISODate\n-            if not isinstance(exercise_data.get(\"timestamp\"), (datetime, type(None))): # Permitir None si lo generas después\n-                 logger.warning(f\"'timestamp' en exercise_data no es un objeto datetime: {type(exercise_data.get('timestamp'))}. Se espera datetime.\")\n+                 logger.error(\"exercise_data: 'problem_difficulty' requerido.\")\n+                 return None # Devolver None en error de validación\n \n+            # --- CORRECCIÓN VALIDACIÓN TIMESTAMP ---\n+            # Validar timestamp de forma más simple y segura\n+            ts = exercise_data.get(\"timestamp\")\n+            if ts is not None and not isinstance(ts, datetime):\n+                 logger.warning(f\"'timestamp' en exercise_data no es datetime: {type(ts)}. Se espera datetime o None.\")\n+                 # Podrías decidir quitarlo o convertirlo si es posible, o simplemente loguear.\n+                 # Por ahora, solo logueamos la advertencia.\n+            # --- FIN CORRECCIÓN ---\n \n-            # Usar $push para añadir el nuevo documento al array 'ejercicios'\n+            # --- CORRECCIÓN VALOR DE RETORNO ---\n+            # Ejecutar update y DEVOLVER el resultado directamente\n             result = self._db.users.update_one(\n                 {\"_id\": user_id},\n                 {\"$push\": {\"ejercicios\": exercise_data}}\n             )\n+            # Ya no retornamos True/False, retornamos el objeto 'result'\n+            return result\n+            # --- FIN CORRECCIÓN ---\n \n-            if result.modified_count > 0:\n-                logger.info(f\"Ejercicio resuelto añadido para user_id: {user_id}\")\n-                return True\n-            else:\n-                logger.warning(f\"No se modificó el documento del usuario {user_id} al añadir ejercicio resuelto. Usuario no encontrado o error.\")\n-                # Podría indicar que el usuario no existe\n-                return False\n-\n         except Exception as e:\n             logger.error(f\"Error al añadir ejercicio resuelto para user_id {user_id}: {str(e)}\")\n-            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n-            return False\n+            return None # Devolver None en caso de excepción de DB\n         \n-# DENTRO de la clase MongoDBClient en mongodb_client.py\n \n     def get_problem_by_id(self, problem_id: ObjectId) -> dict | None:\n         \"\"\"Busca un problema por su ObjectId en la colección 'ejercicios'.\"\"\"\n         # Acceder a la colección a través de self._db\n"
                }
            ],
            "date": 1746139682303,
            "name": "Commit-0",
            "content": "from pymongo import MongoClient\nfrom pymongo.errors import ServerSelectionTimeoutError\nimport logging\nfrom keys import MONGODB_URI, DATABASE_NAME\nfrom typing import Optional\nfrom config import VOICE_SIMILARITY_THRESHOLD\nfrom bson import ObjectId # Importar ObjectId\n\n# Configurar logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(),\n        logging.FileHandler('mongodb_client.log')\n    ]\n)\nlogger = logging.getLogger(__name__)\n\nclass MongoDBClient:\n    _instance = None\n    _client = None\n    _db = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(MongoDBClient, cls).__new__(cls)\n            cls._instance._connect()\n        return cls._instance\n\n    def _connect(self):\n        try:\n            self._client = MongoClient(MONGODB_URI, serverSelectionTimeoutMS=5000)\n            self._db = self._client[DATABASE_NAME]\n            # Verificar la conexión\n            self._client.server_info()\n            logger.info(\"Conexión a MongoDB establecida correctamente\")\n        except ServerSelectionTimeoutError as e:\n            logger.error(f\"Error al conectar con MongoDB: {str(e)}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Error inesperado al conectar con MongoDB: {str(e)}\")\n            raise\n\n    def get_db(self):\n        return self._db\n\n    def get_collection(self, collection_name):\n        return self._db[collection_name]\n\n    def create_user(self, username: str, email: str, password: str, voice_embedding: list = None, voice_url: str = None, voice_embeddings: list = None, face_url: str = None) -> bool:\n        \"\"\"\n        Crea un nuevo usuario en la base de datos\n        \n        Args:\n            username: Nombre del usuario\n            email: Email del usuario\n            password: Contraseña hasheada\n            voice_embedding: Embedding de voz individual (opcional)\n            voice_url: URL del archivo de voz (opcional)\n            voice_embeddings: Lista de embeddings de voz (opcional)\n            face_url: URL de la foto de rostro (opcional)\n            face_url_view: URL del visor de la foto de rostro (opcional)\n            \n        Returns:\n            bool: True si el usuario fue creado exitosamente\n        \"\"\"\n        try:\n            logger.info(f\"Creando usuario: {email}\")\n            \n            # Verificar si el usuario ya existe\n            if self.get_user_by_email(email):\n                logger.warning(f\"El usuario con email {email} ya existe\")\n                return False\n            \n            # Preparar datos del usuario\n            user_data = {\n                \"username\": username,\n                \"email\": email,\n                \"password\": password\n            }\n            \n            # Agregar datos opcionales si existen\n            if voice_embedding is not None:\n                user_data[\"voice_embedding\"] = voice_embedding\n            if voice_embeddings is not None:\n                user_data[\"voice_embeddings\"] = voice_embeddings\n            if voice_url is not None:\n                user_data[\"voice_url\"] = voice_url\n            if face_url is not None:\n                user_data[\"face_url\"] = face_url\n            \n            # Insertar en la base de datos\n            result = self._db.users.insert_one(user_data)\n            \n            if result.inserted_id:\n                logger.info(f\"Usuario creado exitosamente: {email}\")\n                return True\n            else:\n                logger.error(f\"Error al crear usuario: {email}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error al crear usuario {email}: {str(e)}\")\n            return False\n\n    def get_user_by_email(self, email: str) -> dict:\n        \"\"\"\n        Obtiene un usuario por su email\n        \n        Args:\n            email: Email del usuario a buscar\n            \n        Returns:\n            dict: Datos del usuario o None si no existe\n        \"\"\"\n        try:\n            logger.info(f\"Buscando usuario: {email}\")\n            user = self._db.users.find_one({\"email\": email})\n            if user:\n                logger.info(f\"Usuario encontrado: {email}\")\n                return user\n            else:\n                logger.info(f\"Usuario no encontrado: {email}\")\n                return None\n        except Exception as e:\n            logger.error(f\"Error al buscar usuario {email}: {str(e)}\")\n            return None\n\n    def update_user_voice(self, email: str, voice_embedding: list, voice_url: str = None) -> bool:\n        \"\"\"\n        Actualiza los datos de voz de un usuario\n        \n        Args:\n            email: Email del usuario\n            voice_embedding: Nuevo embedding de voz\n            voice_url: Nueva URL del archivo de voz (opcional)\n            \n        Returns:\n            bool: True si la actualización fue exitosa\n        \"\"\"\n        try:\n            logger.info(f\"Actualizando datos de voz para: {email}\")\n            \n            # Preparar datos de actualización\n            update_data = {\n                \"voice_embedding\": voice_embedding\n            }\n            if voice_url is not None:\n                update_data[\"voice_url\"] = voice_url\n            \n            # Actualizar en la base de datos\n            result = self._db.users.update_one(\n                {\"email\": email},\n                {\"$set\": update_data}\n            )\n            \n            if result.modified_count > 0:\n                logger.info(f\"Datos de voz actualizados para: {email}\")\n                return True\n            else:\n                logger.warning(f\"No se actualizaron datos de voz para: {email}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error al actualizar datos de voz para {email}: {str(e)}\")\n            return False\n\n    def verify_user_credentials(self, email: str, password: str) -> dict:\n        \"\"\"\n        Verifica las credenciales de un usuario\n        \n        Args:\n            email: Email del usuario\n            password: Contraseña hasheada\n            \n        Returns:\n            dict: Datos del usuario si las credenciales son correctas, None en caso contrario\n        \"\"\"\n        try:\n            logger.info(f\"Verificando credenciales para: {email}\")\n            \n            # Primero, buscar el usuario por email\n            user = self._db.users.find_one({\"email\": email})\n            \n            if not user:\n                logger.warning(f\"Usuario no encontrado para el email: {email}\")\n                return None\n                \n            # Verificar la contraseña\n            if user.get(\"password\") == password:\n                logger.info(f\"Credenciales válidas para: {email}\")\n                return user\n            else:\n                logger.warning(f\"Contraseña incorrecta para: {email}\")\n                return None\n                \n        except Exception as e:\n            logger.error(f\"Error al verificar credenciales para {email}: {str(e)}\")\n            return None\n\n    def find_user_by_voice(self, voice_embedding: list) -> Optional[dict]:\n        \"\"\"\n        Busca un usuario por su embedding de voz.\n        \n        Args:\n            voice_embedding (list): Embedding de voz a buscar\n            \n        Returns:\n            Optional[dict]: Usuario encontrado o None\n        \"\"\"\n        try:\n            # Importar localmente para evitar importación circular\n            from voice_processing import compare_voices\n            \n            logger.info(\"Buscando usuario por voz\")\n            \n            # Obtener todos los usuarios con embedding de voz (antiguo o nuevo formato)\n            users = list(self._db.users.find({\n                \"$or\": [\n                    {\"voice_embedding\": {\"$exists\": True}},\n                    {\"voice_embeddings\": {\"$exists\": True}}\n                ]\n            }))\n            \n            best_match = None\n            best_similarity = 0\n            \n            # Comparar con cada usuario\n            for user in users:\n                max_similarity = 0\n                \n                # Verificar embeddings individuales si existen\n                if \"voice_embedding\" in user:\n                    user_embedding = user[\"voice_embedding\"]\n                    result = compare_voices(user_embedding, voice_embedding)\n                    similarity = result.get(\"similarity\", 0)\n                    max_similarity = max(max_similarity, similarity)\n                \n                # Verificar galería de embeddings si existe\n                if \"voice_embeddings\" in user and isinstance(user[\"voice_embeddings\"], list):\n                    for stored_embedding in user[\"voice_embeddings\"]:\n                        result = compare_voices(stored_embedding, voice_embedding)\n                        similarity = result.get(\"similarity\", 0)\n                        max_similarity = max(max_similarity, similarity)\n                \n                # Actualizar mejor coincidencia si es necesario\n                if max_similarity > best_similarity:\n                    best_similarity = max_similarity\n                    best_match = user\n            \n            # Verificar si la mejor coincidencia supera el umbral\n            if best_match and best_similarity >= VOICE_SIMILARITY_THRESHOLD:\n                logger.info(f\"Usuario encontrado por voz: {best_match['email']} (similitud: {best_similarity:.4f})\")\n                return best_match\n            \n            logger.info(\"No se encontró usuario con esa voz\")\n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error al buscar usuario por voz: {str(e)}\")\n            raise\n\n    def update_user_voice_gallery(self, email: str, voice_embeddings: list, voice_url: str = None) -> bool:\n        \"\"\"\n        Actualiza la galería de embeddings de voz de un usuario\n        \n        Args:\n            email: Email del usuario\n            voice_embeddings: Lista de embeddings de voz\n            voice_url: Nueva URL del archivo de voz (opcional)\n            \n        Returns:\n            bool: True si la actualización fue exitosa\n        \"\"\"\n        try:\n            logger.info(f\"Actualizando galería de embeddings de voz para: {email}\")\n            \n            # Preparar datos de actualización\n            update_data = {\n                \"voice_embeddings\": voice_embeddings\n            }\n            if voice_url is not None:\n                update_data[\"voice_url\"] = voice_url\n            \n            # Actualizar en la base de datos\n            result = self._db.users.update_one(\n                {\"email\": email},\n                {\"$set\": update_data}\n            )\n            \n            if result.modified_count > 0:\n                logger.info(f\"Galería de voz actualizada para: {email} con {len(voice_embeddings)} embeddings\")\n                return True\n            else:\n                logger.warning(f\"No se actualizó la galería de voz para: {email}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error al actualizar galería de voz para {email}: {str(e)}\")\n            return False\n\n    def get_user_voice_data(self, email: str) -> dict:\n        \"\"\"\n        Obtiene los datos de voz de un usuario\n        \n        Args:\n            email: Email del usuario\n            \n        Returns:\n            dict: Datos de voz del usuario (embeddings y URL) o None si no existen\n        \"\"\"\n        try:\n            logger.info(f\"Obteniendo datos de voz para: {email}\")\n            \n            # Buscar usuario\n            user = self._db.users.find_one(\n                {\"email\": email},\n                {\"voice_embedding\": 1, \"voice_embeddings\": 1, \"voice_url\": 1, \"_id\": 0}\n            )\n            \n            if not user:\n                logger.warning(f\"Usuario no encontrado: {email}\")\n                return None\n                \n            return user\n                \n        except Exception as e:\n            logger.error(f\"Error al obtener datos de voz para {email}: {str(e)}\")\n            return None \n        \n        # Tu get_current_user retorna el dict completo, lo cual es bueno, pero tener get_user_by_id puede ser útil.\n    def get_user_by_id(self, user_id: ObjectId) -> Optional[dict]:\n         \"\"\"Obtiene un usuario por su ObjectId.\"\"\"\n         try:\n             logger.debug(f\"Buscando usuario por ID: {user_id}\")\n             user = self._db.users.find_one({\"_id\": user_id})\n             # No loguear el usuario completo por seguridad\n             if user:\n                 logger.debug(f\"Usuario encontrado por ID: {user_id}\")\n             else:\n                 logger.debug(f\"Usuario no encontrado por ID: {user_id}\")\n             return user\n         except Exception as e:\n             logger.error(f\"Error al buscar usuario por ID {user_id}: {str(e)}\")\n             return None\n\n\n    # --- NUEVOS MÉTODOS PARA LA LÓGICA ---\n\n    def get_random_unsolved_problem(self, user_id: ObjectId, difficulty: Optional[str] = None) -> Optional[dict]:\n        \"\"\"\n        Busca un problema aleatorio que el usuario no haya resuelto, opcionalmente filtrado por dificultad.\n\n        Args:\n            user_id: El ObjectId del usuario.\n            difficulty: Dificultad del problema a buscar (ej. \"basico\", \"intermedio\", \"avanzado\").\n\n        Returns:\n            dict: Un documento de problema (con _id, text, difficulty) o None si no hay problemas sin resolver.\n        \"\"\"\n        try:\n            logger.info(f\"Buscando problema sin resolver para user_id: {user_id}, dificultad: {difficulty}\")\n\n            # 1. Obtener los IDs de los problemas que el usuario ya resolvió\n            user_doc = self._db.users.find_one(\n                {\"_id\": user_id},\n                {\"ejercicios\": 1} # Solo necesitamos el array de ejercicios resueltos\n            )\n            solved_problem_ids = []\n            if user_doc and user_doc.get(\"ejercicios\"):\n                # Extraer solo los problem_id del array de ejercicios resueltos\n                solved_problem_ids = [\n                    exercise[\"problem_id\"]\n                    for exercise in user_doc[\"ejercicios\"]\n                    if \"problem_id\" in exercise # Asegurarse de que el campo existe\n                ]\n            logger.debug(f\"Problemas resueltos por {user_id}: {len(solved_problem_ids)} IDs\")\n\n            # 2. Construir el filtro para la colección de problemas\n            problem_filter = {}\n            if difficulty:\n                problem_filter[\"difficulty\"] = difficulty\n\n            # Excluir los problemas que ya ha resuelto el usuario\n            if solved_problem_ids:\n                 # $nin: not in (excluir IDs que están en la lista solved_problem_ids)\n                problem_filter[\"_id\"] = {\"$nin\": solved_problem_ids}\n            logger.debug(f\"Filtro para buscar problemas: {problem_filter}\")\n\n            # 3. Buscar un problema aleatorio que coincida con el filtro\n            # Usar el pipeline de agregación con $sample para obtener un documento aleatorio\n            pipeline = [\n                {\"$match\": problem_filter},\n                {\"$sample\": {\"size\": 1}} # Obtener 1 documento aleatorio del resultado del $match\n            ]\n\n            # Ejecutar la agregación en la colección de problemas (ejercicios)\n            problem_collection = self._db.ejercicios # Asumiendo que la colección de problemas se llama 'ejercicios'\n            result = list(problem_collection.aggregate(pipeline))\n\n            if result:\n                logger.info(f\"Problema sin resolver encontrado para user_id: {user_id}\")\n                # Devolver el primer (y único) documento del resultado de $sample\n                return result[0]\n            else:\n                logger.info(f\"No se encontraron problemas sin resolver para user_id: {user_id}, dificultad: {difficulty}\")\n                return None # No hay problemas que coincidan con los criterios y no estén resueltos\n\n        except Exception as e:\n            logger.error(f\"Error al buscar problema sin resolver para user_id {user_id}: {str(e)}\")\n            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n            return None\n\n\n    def add_solved_exercise(self, user_id: ObjectId, exercise_data: dict) -> bool:\n        \"\"\"\n        Añade un ejercicio resuelto al array 'ejercicios' del usuario.\n\n        Args:\n            user_id: El ObjectId del usuario.\n            exercise_data: Diccionario con los datos del ejercicio resuelto\n                           (problem_id, problem_difficulty, user_answer, llm_analysis, llm_grade, timestamp).\n\n        Returns:\n            bool: True si la inserción fue exitosa (modified_count > 0).\n        \"\"\"\n        try:\n            logger.info(f\"Añadiendo ejercicio resuelto para user_id: {user_id}\")\n            # Asegúrate de que exercise_data contiene problem_id (ObjectId) y problem_difficulty\n            if not isinstance(exercise_data.get(\"problem_id\"), ObjectId):\n                 logger.error(f\"exercise_data debe contener 'problem_id' de tipo ObjectId. Recibido: {type(exercise_data.get('problem_id'))}\")\n                 return False\n            if not exercise_data.get(\"problem_difficulty\"):\n                 logger.error(\"exercise_data debe contener 'problem_difficulty'.\")\n                 return False\n            # timestamp debe ser un objeto datetime o similar si quieres guardarlo como ISODate\n            if not isinstance(exercise_data.get(\"timestamp\"), (datetime, type(None))): # Permitir None si lo generas después\n                 logger.warning(f\"'timestamp' en exercise_data no es un objeto datetime: {type(exercise_data.get('timestamp'))}. Se espera datetime.\")\n\n\n            # Usar $push para añadir el nuevo documento al array 'ejercicios'\n            result = self._db.users.update_one(\n                {\"_id\": user_id},\n                {\"$push\": {\"ejercicios\": exercise_data}}\n            )\n\n            if result.modified_count > 0:\n                logger.info(f\"Ejercicio resuelto añadido para user_id: {user_id}\")\n                return True\n            else:\n                logger.warning(f\"No se modificó el documento del usuario {user_id} al añadir ejercicio resuelto. Usuario no encontrado o error.\")\n                # Podría indicar que el usuario no existe\n                return False\n\n        except Exception as e:\n            logger.error(f\"Error al añadir ejercicio resuelto para user_id {user_id}: {str(e)}\")\n            # Dependiendo de tu estrategia de manejo de errores, podrías relanzar\n            return False"
        }
    ]
}