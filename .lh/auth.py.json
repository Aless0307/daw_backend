{
    "sourceFile": "auth.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1744950267809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1744950267809,
            "name": "Commit-0",
            "content": "from fastapi import APIRouter, HTTPException, Depends, status, UploadFile, File, Form\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse\nfrom datetime import timedelta\nfrom typing import Optional, Dict\nimport logging\nimport hashlib\nimport os\nfrom utils.auth_utils import create_access_token, get_current_user\nfrom mongodb_client import MongoDBClient\nfrom voice_processing import extract_embedding, compare_voices, verify_voice, preprocess_audio\nfrom azure_storage import upload_voice_recording, download_voice_recording, ensure_azure_storage, upload_face_photo\nfrom config import (\n    SECRET_KEY, \n    ACCESS_TOKEN_EXPIRE_MINUTES, \n    VOICE_SIMILARITY_THRESHOLD,\n    ENVIRONMENT,\n    IS_PRODUCTION\n)\nfrom pydantic import BaseModel\nimport librosa\nimport numpy as np\nimport face_recognition\nimport cv2\nimport time\nimport warnings\nimport onnxruntime as ort\nfrom insightface.app import FaceAnalysis\nimport contextlib\nimport io\nimport requests\nfrom urllib.parse import urlparse\nimport tempfile\n\n# Configurar logging\nlogging.basicConfig(\n    level=logging.INFO if IS_PRODUCTION else logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(),\n        logging.FileHandler('auth.log')\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n# Log del entorno actual\nlogger.info(f\"Ejecutando en entorno: {ENVIRONMENT}\")\n\nrouter = APIRouter()\nmongo_client = MongoDBClient()\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n    email: str\n    voice_url: Optional[str] = None\n\nclass LoginResponse(BaseModel):\n    access_token: str\n    token_type: str\n    username: Optional[str] = None\n    email: str\n    voice_url: Optional[str] = None\n    face_url: Optional[str] = None\n\n# Suprimir warnings molestos\nwarnings.filterwarnings(\"ignore\")\n\n# Silenciar logs internos de onnxruntime\nort.set_default_logger_severity(3)\n\n# ------------------ PREPROCESAMIENTO ------------------ #\ndef preprocess_image(image):\n    height, width = image.shape[:2]\n    max_size = 800\n    if height > max_size or width > max_size:\n        scale = max_size / max(height, width)\n        image = cv2.resize(image, (int(width * scale), int(height * scale)))\n    \n    lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)\n    l, a, b = cv2.split(lab)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    l = clahe.apply(l)\n    lab = cv2.merge((l, a, b))\n    enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n    \n    return enhanced\n\n# ------------------ ARCFACE COMPARISON ------------------ #\ndef compare_faces_arcface(image_path1, image_path2, threshold=0.65):\n    if not os.path.exists(image_path1) or not os.path.exists(image_path2):\n        return \"One or both image files do not exist\", None, None\n\n    start_time = time.time()\n\n    img1 = cv2.imread(image_path1)\n    img2 = cv2.imread(image_path2)\n\n    if img1 is None or img2 is None:\n        return \"Error loading one or both images\", None, None\n\n    img1_rgb = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)\n    img2_rgb = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)\n\n    img1_processed = preprocess_image(img1_rgb)\n    img2_processed = preprocess_image(img2_rgb)\n\n    # Silenciar los prints del modelo durante su inicializaci√≥n\n    f = io.StringIO()\n    with contextlib.redirect_stdout(f):\n        face_analyzer = FaceAnalysis(providers=['CPUExecutionProvider'])\n        face_analyzer.prepare(ctx_id=0, det_size=(640, 640))\n\n    faces1 = face_analyzer.get(cv2.cvtColor(img1_processed, cv2.COLOR_RGB2BGR))\n    faces2 = face_analyzer.get(cv2.cvtColor(img2_processed, cv2.COLOR_RGB2BGR))\n\n    if not faces1 or not faces2:\n        return \"No faces detected in one or both images\", None, None\n\n    embedding1 = faces1[0].embedding\n    embedding2 = faces2[0].embedding\n\n    cosine_sim = np.dot(embedding1, embedding2) / (np.linalg.norm(embedding1) * np.linalg.norm(embedding2))\n    similarity_percentage = cosine_sim * 100\n    match = cosine_sim >= threshold\n\n    execution_time = time.time() - start_time\n\n    return match, similarity_percentage, execution_time\n\n# Funci√≥n para descargar imagen desde URL\ndef download_image(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            # Crear un archivo temporal\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')\n            temp_file.write(response.content)\n            temp_file.close()\n            return temp_file.name\n        return None\n    except Exception as e:\n        logger.error(f\"Error downloading image: {str(e)}\")\n        return None\n\n@router.post(\"/register\", response_model=LoginResponse)\nasync def register(\n    email: str = Form(...),\n    username: str = Form(...),\n    password: str = Form(...),\n    voice_recording: UploadFile = File(None),\n    face_photo: UploadFile = File(None)\n):\n    try:\n        logger.info(f\"Intento de registro para: {email}\")\n\n        # Verificar si el usuario ya existe\n        existing_user = mongo_client.get_user_by_email(email)\n        if existing_user:\n            logger.warning(f\"Intento de registro con email ya existente: {email}\")\n            raise HTTPException(status_code=400, detail=\"El email ya est√° registrado\")\n\n        # Hashear la contrase√±a\n        hashed_password = hashlib.sha256(password.encode()).hexdigest()\n        logger.debug(f\"Contrase√±a hasheada para: {email}\")\n\n        # Procesar la grabaci√≥n de voz si se proporciona\n        voice_embedding = None\n        voice_embeddings = None\n        voice_url = None\n        temp_file = None\n        face_url = None\n        \n        if voice_recording:\n            logger.info(\"Procesando grabaci√≥n de voz\")\n            \n            # Verificar disponibilidad de Azure Storage si se va a subir una grabaci√≥n\n            if not await ensure_azure_storage():\n                logger.warning(\"‚ö†Ô∏è Azure Storage no est√° disponible. El usuario se registrar√° sin voz.\")\n                # No lanzamos excepci√≥n para permitir el registro sin voz\n            else:\n                # Crear directorio temporal\n                temp_dir = \"./temp_files\"\n                if not os.path.exists(temp_dir):\n                    os.makedirs(temp_dir)\n                    \n                # Guardar archivo temporalmente\n                temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n                try:\n                    with open(temp_file, \"wb\") as buffer:\n                        content = await voice_recording.read()\n                        if not content:\n                            raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n                        buffer.write(content)\n                        logger.info(f\"Archivo de voz guardado temporalmente: {temp_file}\")\n\n                    # Extraer embedding\n                    voice_embedding = extract_embedding(temp_file)\n                    if voice_embedding is None:\n                        logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                        # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                    else:\n                        # Crear lista de embeddings\n                        voice_embeddings = [voice_embedding]\n                        \n                        # Subir a Azure Storage\n                        voice_url = await upload_voice_recording(temp_file, email)\n                        if not voice_url:\n                            logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n                            # Continuar sin URL de voz, pero con embedding\n                        else:\n                            logger.info(f\"üì§ Archivo subido a Azure. URL: {voice_url}\")\n                finally:\n                    # Limpiar archivo temporal\n                    if temp_file and os.path.exists(temp_file):\n                        os.remove(temp_file)\n                        logger.debug(\"üßπ Archivo temporal eliminado\")\n\n        if face_photo:\n            logger.info(\"Procesando foto de rostro\")\n            # Crear directorio temporal\n            temp_dir = \"./temp_files\"\n            if not os.path.exists(temp_dir):\n                os.makedirs(temp_dir)\n            image_file = f\"{temp_dir}/face.jpg\"\n            with open(image_file, \"wb\") as buffer:\n                content = await face_photo.read()\n                buffer.write(content)\n                logger.info(f\"Foto de rostro guardada temporalmente: {image_file}\")\n            \n            # Subir a Azure Storage\n            face_url = await upload_face_photo(image_file, email)\n            if not face_url:\n                logger.error(\"‚ùå No se pudo subir la foto de rostro a Azure Storage\")\n            else:\n                logger.info(f\"üì§ Foto de rostro subida a Azure. URL: {face_url}\")\n            \n        # Crear usuario\n        logger.info(\"Creando usuario en MongoDB\")\n        success = mongo_client.create_user(\n            username=username,\n            email=email,\n            password=hashed_password,  # Usar la contrase√±a hasheada\n            voice_embedding=voice_embedding,\n            voice_embeddings=voice_embeddings,\n            voice_url=voice_url,\n            face_url=face_url,\n        )\n\n        if success:\n            logger.info(f\"‚úÖ Usuario registrado exitosamente: {email}\")\n            # Crear token de acceso\n            access_token = create_access_token(data={\"sub\": email})\n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=username,\n                email=email,\n                voice_url=voice_url,\n                face_url=face_url,\n            )\n        else:\n            logger.error(f\"‚ùå Error al crear usuario en la base de datos: {email}\")\n            raise HTTPException(status_code=500, detail=\"Error al crear el usuario\")\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error al registrar usuario: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error en el servidor\")\n\n@router.post(\"/login\", response_model=LoginResponse)\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Inicia sesi√≥n con credenciales (usuario y contrase√±a)\n    \"\"\"\n    try:\n        email = form_data.username  # En OAuth2PasswordRequestForm el email se env√≠a como username\n        logger.info(f\"üîë Intento de inicio de sesi√≥n para: {email}\")\n        \n        # Hashear la contrase√±a\n        hashed_password = hashlib.sha256(form_data.password.encode()).hexdigest()\n        logger.debug(f\"Contrase√±a hasheada para login: {email}\")\n        \n        # Verificar credenciales\n        user = mongo_client.verify_user_credentials(email, hashed_password)\n        if not user:\n            logger.warning(f\"‚ùå Credenciales incorrectas para: {email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Credenciales incorrectas\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        # Crear token\n        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token = create_access_token(\n            data={\"sub\": user[\"email\"]},\n            expires_delta=access_token_expires\n        )\n        \n        logger.info(f\"‚úÖ Login exitoso para: {email}\")\n        \n        return LoginResponse(\n            access_token=access_token,\n            token_type=\"bearer\",\n            username=user.get(\"username\"),\n            email=user[\"email\"],\n            voice_url=user.get(\"voice_url\")\n        )\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error en el login: {str(e)}\")\n        if isinstance(e, HTTPException):\n            raise\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error en el login: {str(e)}\"\n        )\n\n@router.post(\"/login-voice\", response_model=LoginResponse)\nasync def login_with_voice(\n    email: str = Form(...),\n    voice_recording: UploadFile = File(...)\n):\n    # Inicializar variable para evitar error de referencia\n    temp_file = None\n    \n    try:\n        logger.info(f\"üé§ Intento de login con voz para: {email}\")\n        \n        # Verificar tama√±o del archivo\n        content = await voice_recording.read()\n        if len(content) > 15 * 1024 * 1024:  # 15MB\n            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n            raise HTTPException(status_code=400, detail=\"El archivo de audio es demasiado grande (m√°ximo 15MB)\")\n            \n        if len(content) == 0:\n            logger.warning(\"‚ùå Archivo vac√≠o\")\n            raise HTTPException(status_code=400, detail=\"El archivo de audio est√° vac√≠o\")\n        \n        # Buscar usuario por email\n        user = mongo_client.get_user_by_email(email)\n        if not user:\n            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n\n        # Verificar que el usuario tenga una voz registrada\n        if not user.get('voice_url'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene voz registrada\")\n            raise HTTPException(status_code=400, detail=\"No hay voz registrada para este usuario\")\n\n        logger.info(f\"üîç Voice URL del usuario: {user['voice_url']}\")\n        \n        # Verificar si el usuario tiene embeddings de voz registrados\n        if not user.get('voice_embedding') and not user.get('voice_embeddings'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene embeddings de voz registrados\")\n            raise HTTPException(status_code=400, detail=\"No hay datos de voz registrados para este usuario\")\n            \n        # Crear directorio temporal\n        temp_dir = \"./temp_files\"\n        if not os.path.exists(temp_dir):\n            os.makedirs(temp_dir)\n            \n        # Guardar el archivo temporal de la grabaci√≥n\n        temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n        with open(temp_file, \"wb\") as buffer:\n            buffer.write(content)\n            logger.info(f\"üíæ Archivo de voz guardado: {temp_file} ({len(content)} bytes)\")\n        \n        # Importamos verify_voice (usando una instancia temporal del router)\n        from voice_processing import verify_voice as voice_verifier\n        \n        # Preprocesar audio y extraer embedding\n        from voice_processing import preprocess_audio, extract_embedding\n        \n        try:\n            # Preprocesar audio\n            preprocess_audio(temp_file)\n            \n            # Extraer embedding\n            input_embedding = extract_embedding(temp_file)\n            \n            if input_embedding is None:\n                raise HTTPException(\n                    status_code=400,\n                    detail=\"No se pudo procesar el audio. Intente nuevamente en un entorno m√°s silencioso.\"\n                )\n                \n            # Obtener embeddings del usuario desde MongoDB\n            user_data = mongo_client.get_user_voice_data(email)\n            \n            # Verificar contra m√∫ltiples embeddings y tomar el mejor resultado\n            best_similarity = 0\n            is_match = False\n            \n            # Verificar contra la galer√≠a de embeddings si existe\n            for stored_embedding in user_data.get('voice_embeddings', []):\n                from voice_processing import compare_voices\n                result = compare_voices(input_embedding, stored_embedding)\n                if result[\"similarity\"] > best_similarity:\n                    best_similarity = result[\"similarity\"]\n                    is_match = result[\"match\"]\n                    \n            # Si no hay galer√≠a, verificar con el embedding principal\n            if not user_data.get('voice_embeddings') and user_data.get('voice_embedding'):\n                from voice_processing import compare_voices\n                result = compare_voices(input_embedding, user_data['voice_embedding'])\n                best_similarity = result[\"similarity\"]\n                is_match = result[\"match\"]\n            \n            # Verificar si la voz coincide\n            if not is_match:\n                logger.warning(f\"‚ùå Similitud insuficiente: {best_similarity:.2f} < {VOICE_SIMILARITY_THRESHOLD}\")\n                raise HTTPException(status_code=401, detail=\"La voz no coincide\")\n            \n            # Si llegamos aqu√≠, la voz coincide\n            logger.info(f\"‚úÖ Login exitoso para {email} con similitud {best_similarity:.2f}\")\n            \n            # Crear token\n            access_token = create_access_token(data={\"sub\": email})\n            \n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=user.get(\"username\"),\n                email=email,\n                voice_url=user.get(\"voice_url\")\n            )\n            \n        except HTTPException:\n            raise\n        except Exception as e:\n            logger.error(f\"‚ùå Error al procesar la voz: {str(e)}\")\n            raise HTTPException(\n                status_code=500,\n                detail=\"Error al procesar la voz\"\n            )\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error en login con voz: {str(e)}\")\n        import traceback\n        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n        raise HTTPException(\n            status_code=500,\n            detail=\"Error al procesar la autenticaci√≥n por voz\"\n        )\n    finally:\n        # Limpiar archivos temporales\n        if temp_file and os.path.exists(temp_file):\n            try:\n                os.remove(temp_file)\n                logger.debug(\"üßπ Archivo temporal eliminado\")\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal: {str(e)}\")\n\n@router.get(\"/me\", response_model=LoginResponse)\nasync def read_users_me(current_user: dict = Depends(get_current_user)):\n    return LoginResponse(\n        access_token=\"\",\n        token_type=\"bearer\",\n        username=current_user.get(\"username\"),\n        email=current_user[\"email\"],\n        voice_url=current_user.get(\"voice_url\")\n    )\n\n@router.post(\"/login_face\", response_model=LoginResponse)\nasync def login_face(\n    email: str = Form(...),\n    face_photo: UploadFile = File(...)\n):\n    try:\n        logger.info(f\"üì∏ Intento de login con foto para: {email}\")\n        \n        # Verificar tama√±o del archivo\n        content = await face_photo.read()\n        if len(content) > 5 * 1024 * 1024:  # 5MB\n            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n            raise HTTPException(status_code=400, detail=\"La foto es demasiado grande (m√°ximo 5MB)\")\n            \n        if len(content) == 0:\n            logger.warning(\"‚ùå Archivo vac√≠o\")\n            raise HTTPException(status_code=400, detail=\"La foto est√° vac√≠a\")\n        \n        # Buscar usuario por email\n        user = mongo_client.get_user_by_email(email)\n        if not user:\n            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n\n        # Verificar que el usuario tenga una foto registrada\n        if not user.get('face_url'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene foto registrada\")\n            raise HTTPException(status_code=400, detail=\"No hay foto registrada para este usuario\")\n\n        logger.info(f\"üîç Face URL del usuario: {user['face_url']}\")\n        \n        # Crear directorio temporal\n        temp_dir = \"./temp_files\"\n        if not os.path.exists(temp_dir):\n            os.makedirs(temp_dir)\n            \n        # Guardar el archivo temporal de la foto recibida\n        temp_file_received = f\"{temp_dir}/temp_{face_photo.filename}\"\n        with open(temp_file_received, \"wb\") as buffer:\n            buffer.write(content)\n            logger.info(f\"üíæ Foto recibida guardada: {temp_file_received} ({len(content)} bytes)\")\n\n        # Descargar la foto registrada\n        temp_file_registered = download_image(user['face_url'])\n        if not temp_file_registered:\n            raise HTTPException(status_code=500, detail=\"Error al descargar la foto registrada\")\n\n        logger.info(\"üîÑ Iniciando comparaci√≥n facial...\")\n        \n        # Realizar la comparaci√≥n facial\n        match, similarity, exec_time = compare_faces_arcface(temp_file_received, temp_file_registered)\n        \n        logger.info(f\"üìä Resultados de la comparaci√≥n:\")\n        logger.info(f\"   - Coincidencia: {match}\")\n        logger.info(f\"   - Similitud: {similarity:.2f}%\")\n        logger.info(f\"   - Tiempo de ejecuci√≥n: {exec_time:.2f} segundos\")\n\n        # Limpiar archivos temporales\n        if os.path.exists(temp_file_received):\n            os.remove(temp_file_received)\n        if os.path.exists(temp_file_registered):\n            os.remove(temp_file_registered)\n            \n        if match:\n            # Generar token de acceso\n            access_token = create_access_token(data={\"sub\": email})\n            logger.info(f\"‚úÖ Login exitoso para: {email}\")\n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=user.get(\"username\"),\n                email=email,\n                voice_url=user.get(\"voice_url\"),\n                face_url=user.get(\"face_url\")\n            )\n        else:\n            logger.warning(f\"‚ùå Autenticaci√≥n facial fallida para: {email}\")\n            raise HTTPException(\n                status_code=401,\n                detail=\"La autenticaci√≥n facial fall√≥. Las caras no coinciden.\"\n            )\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n        raise HTTPException(\n            status_code=500,\n            detail=\"Error al procesar la autenticaci√≥n por foto\"\n        ) "
        }
    ]
}