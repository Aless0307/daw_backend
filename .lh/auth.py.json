{
    "sourceFile": "auth.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1744950267809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1744950760603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -265,8 +265,9 @@\n         else:\n             logger.error(f\"‚ùå Error al crear usuario en la base de datos: {email}\")\n             raise HTTPException(status_code=500, detail=\"Error al crear el usuario\")\n \n+\n     except HTTPException:\n         raise\n     except Exception as e:\n         logger.error(f\"‚ùå Error al registrar usuario: {str(e)}\")\n"
                },
                {
                    "date": 1744999863558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,8 +175,10 @@\n         face_url = None\n         \n         if voice_recording:\n             logger.info(\"Procesando grabaci√≥n de voz\")\n+            logger.info(f\"Nombre del archivo: {voice_recording.filename}\")\n+            logger.info(f\"Tipo de contenido: {voice_recording.content_type}\")\n             \n             # Verificar disponibilidad de Azure Storage si se va a subir una grabaci√≥n\n             if not await ensure_azure_storage():\n                 logger.warning(\"‚ö†Ô∏è Azure Storage no est√° disponible. El usuario se registrar√° sin voz.\")\n@@ -192,13 +194,34 @@\n                 try:\n                     with open(temp_file, \"wb\") as buffer:\n                         content = await voice_recording.read()\n                         if not content:\n+                            logger.error(\"‚ùå El archivo de voz est√° vac√≠o\")\n                             raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n+                        \n+                        content_size = len(content)\n+                        logger.info(f\"Tama√±o del contenido: {content_size} bytes\")\n+                        \n                         buffer.write(content)\n                         logger.info(f\"Archivo de voz guardado temporalmente: {temp_file}\")\n+                        \n+                        # Verificar que el archivo se escribi√≥ correctamente\n+                        if os.path.exists(temp_file):\n+                            file_size = os.path.getsize(temp_file)\n+                            logger.info(f\"Tama√±o del archivo guardado: {file_size} bytes\")\n+                            if file_size == 0:\n+                                logger.error(\"‚ùå El archivo guardado est√° vac√≠o\")\n+                        else:\n+                            logger.error(\"‚ùå El archivo no se guard√≥ correctamente\")\n+                except Exception as e:\n+                    logger.error(f\"‚ùå Error al guardar el archivo de voz: {str(e)}\")\n+                    if temp_file and os.path.exists(temp_file):\n+                        os.remove(temp_file)\n+                        logger.debug(\"üßπ Archivo temporal eliminado por error\")\n+                    raise HTTPException(status_code=500, detail=\"Error al procesar el archivo de voz\")\n \n-                    # Extraer embedding\n+                # Extraer embedding\n+                try:\n                     voice_embedding = extract_embedding(temp_file)\n                     if voice_embedding is None:\n                         logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                         # No falla el registro, simplemente se crea el usuario sin embedding de voz\n@@ -213,13 +236,13 @@\n                             # Continuar sin URL de voz, pero con embedding\n                         else:\n                             logger.info(f\"üì§ Archivo subido a Azure. URL: {voice_url}\")\n                 finally:\n-                    # Limpiar archivo temporal\n+                    # Limpiar archivo temporal despu√©s de procesarlo\n                     if temp_file and os.path.exists(temp_file):\n                         os.remove(temp_file)\n-                        logger.debug(\"üßπ Archivo temporal eliminado\")\n-\n+                        logger.debug(\"üßπ Archivo temporal eliminado despu√©s de procesamiento\")\n+        \n         if face_photo:\n             logger.info(\"Procesando foto de rostro\")\n             # Crear directorio temporal\n             temp_dir = \"./temp_files\"\n@@ -509,9 +532,9 @@\n         # Guardar el archivo temporal de la foto recibida\n         temp_file_received = f\"{temp_dir}/temp_{face_photo.filename}\"\n         with open(temp_file_received, \"wb\") as buffer:\n             buffer.write(content)\n-            logger.info(f\"üíæ Foto recibida guardada: {temp_file_received} ({len(content)} bytes)\")\n+            logger.info(f\"Foto recibida guardada: {temp_file_received} ({len(content)} bytes)\")\n \n         # Descargar la foto registrada\n         temp_file_registered = download_image(user['face_url'])\n         if not temp_file_registered:\n"
                },
                {
                    "date": 1745111163552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n import cv2\n import time\n import warnings\n import onnxruntime as ort\n-from insightface.app import FaceAnalysis\n+from face_model import face_analyzer\n import contextlib\n import io\n import requests\n from urllib.parse import urlparse\n@@ -109,11 +109,8 @@\n     img2_processed = preprocess_image(img2_rgb)\n \n     # Silenciar los prints del modelo durante su inicializaci√≥n\n     f = io.StringIO()\n-    with contextlib.redirect_stdout(f):\n-        face_analyzer = FaceAnalysis(providers=['CPUExecutionProvider'])\n-        face_analyzer.prepare(ctx_id=0, det_size=(640, 640))\n \n     faces1 = face_analyzer.get(cv2.cvtColor(img1_processed, cv2.COLOR_RGB2BGR))\n     faces2 = face_analyzer.get(cv2.cvtColor(img2_processed, cv2.COLOR_RGB2BGR))\n \n"
                },
                {
                    "date": 1745113030224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,5 +578,13 @@\n         logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n         raise HTTPException(\n             status_code=500,\n             detail=\"Error al procesar la autenticaci√≥n por foto\"\n-        ) \n\\ No newline at end of file\n+        ) \n+    \n+# En daw_backend/auth.py o routes/user.py\n+@router.get(\"/user_by_email\")\n+async def user_by_email(email: str):\n+    user = mongo_client.get_user_by_email(email)\n+    if not user:\n+        raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n+    return user\n"
                },
                {
                    "date": 1746119671056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,11 +580,107 @@\n             status_code=500,\n             detail=\"Error al procesar la autenticaci√≥n por foto\"\n         ) \n     \n-# En daw_backend/auth.py o routes/user.py\n-@router.get(\"/user_by_email\")\n+#Corrigiendo el error de CORS para la obtenci√≥n del object_id\n+# Importaciones necesarias (aseg√∫rate de tener pydantic instalado: pip install pydantic)\n+from fastapi import APIRouter, HTTPException\n+# Aseg√∫rate de que estas importaciones coincidan con d√≥nde tienes tu mongo_client\n+# y c√≥mo PyMongo/BSON se importa en tu proyecto.\n+from pymongo.collection import Collection # Si get_user_by_email devuelve un dict de pymongo\n+from bson import ObjectId # Necesario para decirle a Pydantic c√≥mo serializarlo\n+from pydantic import BaseModel, Field # Necesario para definir el modelo\n+\n+# Opcional: pydantic-mongo simplifica el manejo de ObjectId en modelos\n+# pip install pydantic-mongo\n+# from pydantic_mongo import ObjectIdField\n+\n+\n+# Suponiendo que tu router est√° definido en este archivo o importado\n+router = APIRouter()\n+\n+\n+# ----- Define el Modelo Pydantic para la Respuesta del Usuario -----\n+# Este modelo describe C√ìMO se ver√°n los datos del usuario en la respuesta JSON al frontend.\n+\n+class UserResponseModel(BaseModel):\n+    # Usamos un alias para mapear el campo '_id' de MongoDB (que es ObjectId)\n+    # a un campo llamado 'id' en nuestro modelo Pydantic y en el JSON de respuesta.\n+    # Lo definimos como 'str' porque en JSON, el ObjectId se representa como string.\n+    id: str = Field(alias='_id')\n+\n+    # A√±ade aqu√≠ los otros campos que esperas retornar del documento de usuario\n+    email: str\n+    username: str # Ejemplo: si el documento tiene un campo 'username'\n+\n+    # Puedes a√±adir otros campos si los retorna tu consulta a MongoDB\n+    # is_active: bool = True # Ejemplo\n+\n+    class Config:\n+        # Permite a Pydantic mapear el nombre del campo '_id' de la fuente de datos (MongoDB dict)\n+        # al nombre del campo 'id' en el modelo.\n+        populate_by_name = True # Para Pydantic V2+\n+        # alias_generator = lambda x: x.lstrip('_') # Alternativa para quitar el _ del inicio si todos los campos tienen _\n+\n+        # Informa a Pydantic c√≥mo convertir tipos espec√≠ficos (como ObjectId) a tipos JSON.\n+        # Le decimos que un ObjectId debe ser convertido a su representaci√≥n string.\n+        json_encoders = {ObjectId: str} # Para Pydantic V1 y V2 (aunque en V2+ hay json_schema_extra para docs)\n+\n+        # Para Pydantic V2+, tambi√©n puedes a√±adir esto para la documentaci√≥n OpenAPI (Swagger UI)\n+        # json_schema_extra = {\n+        #     \"examples\": [\n+        #         {\n+        #             \"id\": \"60d5ec49b8f9c40e6c1a0d9e\", # Ejemplo de ObjectId como string\n+        #             \"email\": \"test@example.com\",\n+        #             \"username\": \"testuser\"\n+        #             # ... otros campos\n+        #         }\n+        #     ]\n+        # }\n+\n+    # Si usaras pydantic-mongo, el modelo podr√≠a ser un poco diferente:\n+    # from pydantic_mongo import ObjectIdField\n+    # class UserResponseModel(BaseModel):\n+    #     id: ObjectIdField = Field(alias='_id') # pydantic-mongo's type handles validation and serialization\n+    #     email: str\n+    #     username: str\n+    #     class Config:\n+    #          populate_by_name = True\n+            # json_encoders={ObjectId: str} # might still be needed depending on exact setup\n+            # ...\n+\n+# ----- La Funci√≥n del Endpoint Corregida Usando response_model -----\n+\n+@router.get(\"/user_by_email\", response_model=UserResponseModel) # <-- Usamos el modelo aqu√≠\n async def user_by_email(email: str):\n-    user = mongo_client.get_user_by_email(email)\n-    if not user:\n+    # Asumimos que mongo_client.get_user_by_email retorna un DICCIONARIO de PyMongo\n+    user_document = mongo_client.get_user_by_email(email)\n+\n+    if not user_document:\n+        # FastAPI maneja esta excepci√≥n y retorna un 404\n         raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n-    return user\n+\n+    # Si user_document es un diccionario (el caso m√°s com√∫n con PyMongo find_one),\n+    # FastAPI y Pydantic (gracias a response_model y Config) autom√°ticamente:\n+    # 1. Validar√°n que el diccionario coincida con UserResponseModel.\n+    # 2. Mapear√°n '_id' del diccionario a 'id' del modelo.\n+    # 3. Serializar√°n el ObjectId del '_id' a su representaci√≥n string usando json_encoders={ObjectId: str}.\n+    # 4. Retornar√°n el JSON validado y serializado al frontend.\n+\n+    return user_document\n+\n+    # Si mongo_client.get_user_by_email retornara un objeto de un tipo personalizado\n+    # que NO es un diccionario est√°ndar o no tiene __dict__, podr√≠as necesitar\n+    # convertirlo expl√≠citamente al modelo:\n+    # try:\n+    #     # Usa .model_validate() para Pydantic V2+\n+    #     # Usa .parse_obj() para Pydantic V1\n+    #     return UserResponseModel.model_validate(user_document)\n+    # except Exception as e:\n+    #      # Esto capturar√≠a errores si user_document no es compatible con el modelo\n+    #      print(f\"DEBUG BACKEND: Error al validar/parsear documento del usuario: {e}\")\n+    #      raise HTTPException(status_code=500, detail=f\"Error interno al procesar datos del usuario: {e}\")\n+\n+\n+# Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n+# app = FastAPI(...)\n+# app.include_router(router, prefix=\"/auth\") # Si este router est√° bajo /auth\n\\ No newline at end of file\n"
                },
                {
                    "date": 1746119817478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,107 +580,11 @@\n             status_code=500,\n             detail=\"Error al procesar la autenticaci√≥n por foto\"\n         ) \n     \n-#Corrigiendo el error de CORS para la obtenci√≥n del object_id\n-# Importaciones necesarias (aseg√∫rate de tener pydantic instalado: pip install pydantic)\n-from fastapi import APIRouter, HTTPException\n-# Aseg√∫rate de que estas importaciones coincidan con d√≥nde tienes tu mongo_client\n-# y c√≥mo PyMongo/BSON se importa en tu proyecto.\n-from pymongo.collection import Collection # Si get_user_by_email devuelve un dict de pymongo\n-from bson import ObjectId # Necesario para decirle a Pydantic c√≥mo serializarlo\n-from pydantic import BaseModel, Field # Necesario para definir el modelo\n-\n-# Opcional: pydantic-mongo simplifica el manejo de ObjectId en modelos\n-# pip install pydantic-mongo\n-# from pydantic_mongo import ObjectIdField\n-\n-\n-# Suponiendo que tu router est√° definido en este archivo o importado\n-router = APIRouter()\n-\n-\n-# ----- Define el Modelo Pydantic para la Respuesta del Usuario -----\n-# Este modelo describe C√ìMO se ver√°n los datos del usuario en la respuesta JSON al frontend.\n-\n-class UserResponseModel(BaseModel):\n-    # Usamos un alias para mapear el campo '_id' de MongoDB (que es ObjectId)\n-    # a un campo llamado 'id' en nuestro modelo Pydantic y en el JSON de respuesta.\n-    # Lo definimos como 'str' porque en JSON, el ObjectId se representa como string.\n-    id: str = Field(alias='_id')\n-\n-    # A√±ade aqu√≠ los otros campos que esperas retornar del documento de usuario\n-    email: str\n-    username: str # Ejemplo: si el documento tiene un campo 'username'\n-\n-    # Puedes a√±adir otros campos si los retorna tu consulta a MongoDB\n-    # is_active: bool = True # Ejemplo\n-\n-    class Config:\n-        # Permite a Pydantic mapear el nombre del campo '_id' de la fuente de datos (MongoDB dict)\n-        # al nombre del campo 'id' en el modelo.\n-        populate_by_name = True # Para Pydantic V2+\n-        # alias_generator = lambda x: x.lstrip('_') # Alternativa para quitar el _ del inicio si todos los campos tienen _\n-\n-        # Informa a Pydantic c√≥mo convertir tipos espec√≠ficos (como ObjectId) a tipos JSON.\n-        # Le decimos que un ObjectId debe ser convertido a su representaci√≥n string.\n-        json_encoders = {ObjectId: str} # Para Pydantic V1 y V2 (aunque en V2+ hay json_schema_extra para docs)\n-\n-        # Para Pydantic V2+, tambi√©n puedes a√±adir esto para la documentaci√≥n OpenAPI (Swagger UI)\n-        # json_schema_extra = {\n-        #     \"examples\": [\n-        #         {\n-        #             \"id\": \"60d5ec49b8f9c40e6c1a0d9e\", # Ejemplo de ObjectId como string\n-        #             \"email\": \"test@example.com\",\n-        #             \"username\": \"testuser\"\n-        #             # ... otros campos\n-        #         }\n-        #     ]\n-        # }\n-\n-    # Si usaras pydantic-mongo, el modelo podr√≠a ser un poco diferente:\n-    # from pydantic_mongo import ObjectIdField\n-    # class UserResponseModel(BaseModel):\n-    #     id: ObjectIdField = Field(alias='_id') # pydantic-mongo's type handles validation and serialization\n-    #     email: str\n-    #     username: str\n-    #     class Config:\n-    #          populate_by_name = True\n-            # json_encoders={ObjectId: str} # might still be needed depending on exact setup\n-            # ...\n-\n-# ----- La Funci√≥n del Endpoint Corregida Usando response_model -----\n-\n-@router.get(\"/user_by_email\", response_model=UserResponseModel) # <-- Usamos el modelo aqu√≠\n+# En daw_backend/auth.py o routes/user.py\n+@router.get(\"/user_by_email\")\n async def user_by_email(email: str):\n-    # Asumimos que mongo_client.get_user_by_email retorna un DICCIONARIO de PyMongo\n-    user_document = mongo_client.get_user_by_email(email)\n-\n-    if not user_document:\n-        # FastAPI maneja esta excepci√≥n y retorna un 404\n+    user = mongo_client.get_user_by_email(email)\n+    if not user:\n         raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n-\n-    # Si user_document es un diccionario (el caso m√°s com√∫n con PyMongo find_one),\n-    # FastAPI y Pydantic (gracias a response_model y Config) autom√°ticamente:\n-    # 1. Validar√°n que el diccionario coincida con UserResponseModel.\n-    # 2. Mapear√°n '_id' del diccionario a 'id' del modelo.\n-    # 3. Serializar√°n el ObjectId del '_id' a su representaci√≥n string usando json_encoders={ObjectId: str}.\n-    # 4. Retornar√°n el JSON validado y serializado al frontend.\n-\n-    return user_document\n-\n-    # Si mongo_client.get_user_by_email retornara un objeto de un tipo personalizado\n-    # que NO es un diccionario est√°ndar o no tiene __dict__, podr√≠as necesitar\n-    # convertirlo expl√≠citamente al modelo:\n-    # try:\n-    #     # Usa .model_validate() para Pydantic V2+\n-    #     # Usa .parse_obj() para Pydantic V1\n-    #     return UserResponseModel.model_validate(user_document)\n-    # except Exception as e:\n-    #      # Esto capturar√≠a errores si user_document no es compatible con el modelo\n-    #      print(f\"DEBUG BACKEND: Error al validar/parsear documento del usuario: {e}\")\n-    #      raise HTTPException(status_code=500, detail=f\"Error interno al procesar datos del usuario: {e}\")\n-\n\\ No newline at end of file\n-\n-# Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n-# app = FastAPI(...)\n-# app.include_router(router, prefix=\"/auth\") # Si este router est√° bajo /auth\n+    return user\n"
                },
                {
                    "date": 1746120256321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,45 +1,57 @@\n from fastapi import APIRouter, HTTPException, Depends, status, UploadFile, File, Form\n from fastapi.security import OAuth2PasswordRequestForm\n from fastapi.responses import JSONResponse\n from datetime import timedelta\n-from typing import Optional, Dict\n+from typing import Optional, Dict, List # Importar List si voice_embeddings es una lista\n import logging\n import hashlib\n import os\n from utils.auth_utils import create_access_token, get_current_user\n+# Aseg√∫rate de que la importaci√≥n de MongoDBClient sea correcta para tu estructura de proyecto\n from mongodb_client import MongoDBClient\n+# Aseg√∫rate de que las importaciones de voice_processing sean correctas\n from voice_processing import extract_embedding, compare_voices, verify_voice, preprocess_audio\n+# Aseg√∫rate de que las importaciones de azure_storage sean correctas\n from azure_storage import upload_voice_recording, download_voice_recording, ensure_azure_storage, upload_face_photo\n+# Aseg√∫rate de que la importaci√≥n de config sea correcta\n from config import (\n-    SECRET_KEY, \n-    ACCESS_TOKEN_EXPIRE_MINUTES, \n+    SECRET_KEY,\n+    ACCESS_TOKEN_EXPIRE_MINUTES,\n     VOICE_SIMILARITY_THRESHOLD,\n     ENVIRONMENT,\n-    IS_PRODUCTION\n+    IS_PRODUCTION,\n+    ALLOWED_ORIGINS # Importar ALLOWED_ORIGINS para la config de CORS\n )\n-from pydantic import BaseModel\n+# Importaciones para Pydantic y BSON\n+from pydantic import BaseModel, Field\n+from bson import ObjectId # Necesario para la serializaci√≥n de ObjectId\n+from fastapi.middleware.cors import CORSMiddleware # Importar CORSMiddleware\n+\n+# Otras importaciones que ya ten√≠as\n import librosa\n import numpy as np\n import face_recognition\n import cv2\n import time\n import warnings\n import onnxruntime as ort\n+# Aseg√∫rate de que la importaci√≥n de face_model sea correcta\n from face_model import face_analyzer\n import contextlib\n import io\n import requests\n from urllib.parse import urlparse\n import tempfile\n+import traceback # Para imprimir stack trace en errores\n \n # Configurar logging\n logging.basicConfig(\n     level=logging.INFO if IS_PRODUCTION else logging.DEBUG,\n     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n     handlers=[\n         logging.StreamHandler(),\n-        logging.FileHandler('auth.log')\n+        logging.FileHandler('auth.log') # Considera usar logging.FileHandler con un path absoluto o relativo seguro\n     ]\n )\n logger = logging.getLogger(__name__)\n \n@@ -48,8 +60,27 @@\n \n router = APIRouter()\n mongo_client = MongoDBClient()\n \n+# ----- Configurar CORS (Aseg√∫rate de que ALLOWED_ORIGINS no contenga \"*\" si allow_credentials es True) -----\n+CORS_CONFIG = {\n+    \"allow_origins\": ALLOWED_ORIGINS, # Debe contener las URLs exactas de tu frontend (ej: [\"http://localhost:5173\", \"https://daw-frontend.vercel.app\"])\n+    \"allow_credentials\": True, # Necesario si tu frontend env√≠a cookies o headers de Authorization\n+    \"allow_methods\": [\"*\"], # O especifica solo los m√©todos que usas (GET, POST, OPTIONS, etc.)\n+    \"allow_headers\": [\"*\"], # O especifica solo los headers que usas (Authorization, Content-Type, etc.)\n+}\n+\n+# Asumiendo que 'app' es tu instancia principal de FastAPI definida en otro lugar (ej: main.py)\n+# Debes a√±adir este middleware a tu instancia principal de FastAPI, no necesariamente aqu√≠\n+# app.add_middleware(\n+#     CORSMiddleware,\n+#     **CORS_CONFIG\n+# )\n+# Si este archivo es solo el router, la configuraci√≥n de CORS debe estar en el archivo principal de la app FastAPI.\n+\n+\n+# ----- Definici√≥n de Modelos Pydantic -----\n+\n class Token(BaseModel):\n     access_token: str\n     token_type: str\n \n@@ -65,8 +96,40 @@\n     email: str\n     voice_url: Optional[str] = None\n     face_url: Optional[str] = None\n \n+# --- NUEVO MODELO PARA LA RESPUESTA DEL ENDPOINT user_by_email ---\n+class UserResponseModel(BaseModel):\n+    # Mapea el campo '_id' de MongoDB (ObjectId) a 'id' en el modelo y JSON\n+    id: str = Field(alias='_id')\n+\n+    # A√±ade aqu√≠ los otros campos del usuario que quieres retornar\n+    email: str\n+    username: Optional[str] = None # Asumiendo que username puede ser opcional\n+\n+    # A√±ade otros campos si tu documento de usuario los tiene y quieres retornarlos\n+    # voice_url: Optional[str] = None\n+    # face_url: Optional[str] = None\n+\n+    class Config:\n+        # Configuraci√≥n para Pydantic V2+\n+        populate_by_name = True # Permite mapear por alias ('_id' a 'id')\n+\n+        # Configuraci√≥n para serializar ObjectId a string\n+        json_encoders = {ObjectId: str} # Para Pydantic V1 y V2\n+\n+        # Para Pydantic V2+, tambi√©n puedes a√±adir ejemplos para la documentaci√≥n\n+        # json_schema_extra = {\n+        #     \"examples\": [\n+        #         {\n+        #             \"id\": \"60d5ec49b8f9c40e6c1a0d9e\",\n+        #             \"email\": \"test@example.com\",\n+        #             \"username\": \"testuser\"\n+        #         }\n+        #     ]\n+        # }\n+\n+\n # Suprimir warnings molestos\n warnings.filterwarnings(\"ignore\")\n \n # Silenciar logs internos de onnxruntime\n@@ -78,29 +141,31 @@\n     max_size = 800\n     if height > max_size or width > max_size:\n         scale = max_size / max(height, width)\n         image = cv2.resize(image, (int(width * scale), int(height * scale)))\n-    \n+\n     lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)\n     l, a, b = cv2.split(lab)\n     clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n     l = clahe.apply(l)\n     lab = cv2.merge((l, a, b))\n     enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n-    \n+\n     return enhanced\n \n # ------------------ ARCFACE COMPARISON ------------------ #\n def compare_faces_arcface(image_path1, image_path2, threshold=0.65):\n     if not os.path.exists(image_path1) or not os.path.exists(image_path2):\n+        logger.error(\"One or both image files do not exist\")\n         return \"One or both image files do not exist\", None, None\n \n     start_time = time.time()\n \n     img1 = cv2.imread(image_path1)\n     img2 = cv2.imread(image_path2)\n \n     if img1 is None or img2 is None:\n+        logger.error(\"Error loading one or both images\")\n         return \"Error loading one or both images\", None, None\n \n     img1_rgb = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)\n     img2_rgb = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)\n@@ -108,14 +173,17 @@\n     img1_processed = preprocess_image(img1_rgb)\n     img2_processed = preprocess_image(img2_rgb)\n \n     # Silenciar los prints del modelo durante su inicializaci√≥n\n-    f = io.StringIO()\n-\n+    # Esto parece ser un remanente de depuraci√≥n, considera eliminarlo si no es necesario\n+    # f = io.StringIO()\n+    # with contextlib.redirect_stdout(f):\n     faces1 = face_analyzer.get(cv2.cvtColor(img1_processed, cv2.COLOR_RGB2BGR))\n     faces2 = face_analyzer.get(cv2.cvtColor(img2_processed, cv2.COLOR_RGB2BGR))\n \n+\n     if not faces1 or not faces2:\n+        logger.warning(\"No faces detected in one or both images\")\n         return \"No faces detected in one or both images\", None, None\n \n     embedding1 = faces1[0].embedding\n     embedding2 = faces2[0].embedding\n@@ -124,8 +192,9 @@\n     similarity_percentage = cosine_sim * 100\n     match = cosine_sim >= threshold\n \n     execution_time = time.time() - start_time\n+    logger.debug(f\"Face comparison done in {execution_time:.4f} seconds\")\n \n     return match, similarity_percentage, execution_time\n \n # Funci√≥n para descargar imagen desde URL\n@@ -133,13 +202,17 @@\n     try:\n         response = requests.get(url)\n         if response.status_code == 200:\n             # Crear un archivo temporal\n+            # Usar delete=False para que el archivo no se elimine inmediatamente al cerrarse\n             temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')\n             temp_file.write(response.content)\n-            temp_file.close()\n+            temp_file.close() # Cerrar el archivo para poder usar su nombre\n+            logger.debug(f\"Downloaded image to temporary file: {temp_file.name}\")\n             return temp_file.name\n-        return None\n+        else:\n+            logger.error(f\"Error downloading image from {url}: Status code {response.status_code}\")\n+            return None\n     except Exception as e:\n         logger.error(f\"Error downloading image: {str(e)}\")\n         return None\n \n@@ -150,8 +223,12 @@\n     password: str = Form(...),\n     voice_recording: UploadFile = File(None),\n     face_photo: UploadFile = File(None)\n ):\n+    # Inicializar variables para limpieza final\n+    temp_voice_file = None\n+    temp_face_file = None\n+\n     try:\n         logger.info(f\"Intento de registro para: {email}\")\n \n         # Verificar si el usuario ya existe\n@@ -165,18 +242,16 @@\n         logger.debug(f\"Contrase√±a hasheada para: {email}\")\n \n         # Procesar la grabaci√≥n de voz si se proporciona\n         voice_embedding = None\n-        voice_embeddings = None\n+        voice_embeddings = None # Considera si quieres almacenar m√∫ltiples embeddings al registrar\n         voice_url = None\n-        temp_file = None\n-        face_url = None\n-        \n+\n         if voice_recording:\n             logger.info(\"Procesando grabaci√≥n de voz\")\n             logger.info(f\"Nombre del archivo: {voice_recording.filename}\")\n             logger.info(f\"Tipo de contenido: {voice_recording.content_type}\")\n-            \n+\n             # Verificar disponibilidad de Azure Storage si se va a subir una grabaci√≥n\n             if not await ensure_azure_storage():\n                 logger.warning(\"‚ö†Ô∏è Azure Storage no est√° disponible. El usuario se registrar√° sin voz.\")\n                 # No lanzamos excepci√≥n para permitir el registro sin voz\n@@ -184,89 +259,99 @@\n                 # Crear directorio temporal\n                 temp_dir = \"./temp_files\"\n                 if not os.path.exists(temp_dir):\n                     os.makedirs(temp_dir)\n-                    \n+\n                 # Guardar archivo temporalmente\n-                temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n-                try:\n-                    with open(temp_file, \"wb\") as buffer:\n-                        content = await voice_recording.read()\n-                        if not content:\n-                            logger.error(\"‚ùå El archivo de voz est√° vac√≠o\")\n-                            raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n-                        \n-                        content_size = len(content)\n-                        logger.info(f\"Tama√±o del contenido: {content_size} bytes\")\n-                        \n-                        buffer.write(content)\n-                        logger.info(f\"Archivo de voz guardado temporalmente: {temp_file}\")\n-                        \n-                        # Verificar que el archivo se escribi√≥ correctamente\n-                        if os.path.exists(temp_file):\n-                            file_size = os.path.getsize(temp_file)\n-                            logger.info(f\"Tama√±o del archivo guardado: {file_size} bytes\")\n-                            if file_size == 0:\n-                                logger.error(\"‚ùå El archivo guardado est√° vac√≠o\")\n-                        else:\n-                            logger.error(\"‚ùå El archivo no se guard√≥ correctamente\")\n-                except Exception as e:\n-                    logger.error(f\"‚ùå Error al guardar el archivo de voz: {str(e)}\")\n-                    if temp_file and os.path.exists(temp_file):\n-                        os.remove(temp_file)\n-                        logger.debug(\"üßπ Archivo temporal eliminado por error\")\n-                    raise HTTPException(status_code=500, detail=\"Error al procesar el archivo de voz\")\n+                # Usar tempfile para nombres √∫nicos y manejo m√°s seguro\n+                with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{voice_recording.filename}\") as tmp:\n+                    temp_voice_file = tmp.name\n+                    content = await voice_recording.read()\n+                    if not content:\n+                        logger.error(\"‚ùå El archivo de voz est√° vac√≠o\")\n+                        raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n \n+                    content_size = len(content)\n+                    logger.info(f\"Tama√±o del contenido: {content_size} bytes\")\n+                    tmp.write(content)\n+                    logger.info(f\"Archivo de voz guardado temporalmente: {temp_voice_file}\")\n+\n+                # Verificar que el archivo se escribi√≥ correctamente\n+                if os.path.exists(temp_voice_file):\n+                    file_size = os.path.getsize(temp_voice_file)\n+                    logger.info(f\"Tama√±o del archivo guardado: {file_size} bytes\")\n+                    if file_size == 0:\n+                        logger.error(\"‚ùå El archivo guardado est√° vac√≠o\")\n+                        raise HTTPException(status_code=400, detail=\"El archivo de voz guardado est√° vac√≠o\")\n+                else:\n+                    logger.error(\"‚ùå El archivo no se guard√≥ correctamente\")\n+                    raise HTTPException(status_code=500, detail=\"Error al guardar el archivo de voz\")\n+\n+\n                 # Extraer embedding\n                 try:\n-                    voice_embedding = extract_embedding(temp_file)\n+                    # Aseg√∫rate de que preprocess_audio maneje el path correctamente\n+                    preprocess_audio(temp_voice_file) # Preprocesar el archivo temporal\n+                    voice_embedding = extract_embedding(temp_voice_file) # Extraer del archivo temporal\n+\n                     if voice_embedding is None:\n                         logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                         # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                     else:\n-                        # Crear lista de embeddings\n-                        voice_embeddings = [voice_embedding]\n-                        \n+                         # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n+                         # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n+                         voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n+\n+\n                         # Subir a Azure Storage\n-                        voice_url = await upload_voice_recording(temp_file, email)\n+                        voice_url = await upload_voice_recording(temp_voice_file, email)\n                         if not voice_url:\n                             logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n                             # Continuar sin URL de voz, pero con embedding\n                         else:\n                             logger.info(f\"üì§ Archivo subido a Azure. URL: {voice_url}\")\n-                finally:\n-                    # Limpiar archivo temporal despu√©s de procesarlo\n-                    if temp_file and os.path.exists(temp_file):\n-                        os.remove(temp_file)\n-                        logger.debug(\"üßπ Archivo temporal eliminado despu√©s de procesamiento\")\n-        \n+                except Exception as e:\n+                     logger.error(f\"‚ùå Error durante el procesamiento o subida de voz: {str(e)}\")\n+                     # Considera si quieres lanzar una HTTPException aqu√≠ o simplemente loguear y continuar\n+                     # raise HTTPException(status_code=500, detail=\"Error al procesar o subir la grabaci√≥n de voz\")\n+\n+\n         if face_photo:\n             logger.info(\"Procesando foto de rostro\")\n             # Crear directorio temporal\n             temp_dir = \"./temp_files\"\n             if not os.path.exists(temp_dir):\n                 os.makedirs(temp_dir)\n-            image_file = f\"{temp_dir}/face.jpg\"\n-            with open(image_file, \"wb\") as buffer:\n+\n+            # Guardar archivo temporalmente\n+            with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{face_photo.filename}\") as tmp:\n+                temp_face_file = tmp.name\n                 content = await face_photo.read()\n-                buffer.write(content)\n-                logger.info(f\"Foto de rostro guardada temporalmente: {image_file}\")\n-            \n+                if not content:\n+                     logger.error(\"‚ùå El archivo de foto est√° vac√≠o\")\n+                     raise HTTPException(status_code=400, detail=\"El archivo de foto est√° vac√≠o\")\n+                tmp.write(content)\n+                logger.info(f\"Foto de rostro guardada temporalmente: {temp_face_file}\")\n+\n             # Subir a Azure Storage\n-            face_url = await upload_face_photo(image_file, email)\n+            face_url = await upload_face_photo(temp_face_file, email)\n             if not face_url:\n                 logger.error(\"‚ùå No se pudo subir la foto de rostro a Azure Storage\")\n+                # Considera si quieres lanzar una HTTPException aqu√≠ o simplemente loguear y continuar\n+                # raise HTTPException(status_code=500, detail=\"Error al subir la foto de rostro\")\n             else:\n                 logger.info(f\"üì§ Foto de rostro subida a Azure. URL: {face_url}\")\n-            \n+\n+\n         # Crear usuario\n         logger.info(\"Creando usuario en MongoDB\")\n+        # Aseg√∫rate de que create_user pueda manejar voice_embedding y voice_embeddings (lista)\n         success = mongo_client.create_user(\n             username=username,\n             email=email,\n             password=hashed_password,  # Usar la contrase√±a hasheada\n-            voice_embedding=voice_embedding,\n-            voice_embeddings=voice_embeddings,\n+            voice_embedding=voice_embedding.tolist() if voice_embedding is not None else None, # Guardar como lista si existe\n+            voice_embeddings=voice_embeddings, # Guardar la lista si se gener√≥\n             voice_url=voice_url,\n             face_url=face_url,\n         )\n \n@@ -287,57 +372,80 @@\n             raise HTTPException(status_code=500, detail=\"Error al crear el usuario\")\n \n \n     except HTTPException:\n+        # Si ya es una HTTPException, simplemente la relanzamos\n         raise\n     except Exception as e:\n+        # Para otros errores, logueamos el stack trace y retornamos un 500\n         logger.error(f\"‚ùå Error al registrar usuario: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n         raise HTTPException(status_code=500, detail=\"Error en el servidor\")\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_voice_file and os.path.exists(temp_voice_file):\n+            try:\n+                os.remove(temp_voice_file)\n+                logger.debug(f\"üßπ Archivo temporal de voz eliminado: {temp_voice_file}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de voz {temp_voice_file}: {str(e)}\")\n+        if temp_face_file and os.path.exists(temp_face_file):\n+            try:\n+                os.remove(temp_face_file)\n+                logger.debug(f\"üßπ Archivo temporal de foto eliminado: {temp_face_file}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto {temp_face_file}: {str(e)}\")\n \n+\n @router.post(\"/login\", response_model=LoginResponse)\n async def login(form_data: OAuth2PasswordRequestForm = Depends()):\n     \"\"\"\n     Inicia sesi√≥n con credenciales (usuario y contrase√±a)\n     \"\"\"\n     try:\n         email = form_data.username  # En OAuth2PasswordRequestForm el email se env√≠a como username\n         logger.info(f\"üîë Intento de inicio de sesi√≥n para: {email}\")\n-        \n+\n         # Hashear la contrase√±a\n         hashed_password = hashlib.sha256(form_data.password.encode()).hexdigest()\n         logger.debug(f\"Contrase√±a hasheada para login: {email}\")\n-        \n+\n         # Verificar credenciales\n+        # Aseg√∫rate de que verify_user_credentials retorna un diccionario con 'email', 'username', 'voice_url', etc.\n         user = mongo_client.verify_user_credentials(email, hashed_password)\n         if not user:\n             logger.warning(f\"‚ùå Credenciales incorrectas para: {email}\")\n             raise HTTPException(\n                 status_code=status.HTTP_401_UNAUTHORIZED,\n                 detail=\"Credenciales incorrectas\",\n                 headers={\"WWW-Authenticate\": \"Bearer\"},\n             )\n-        \n+\n         # Crear token\n         access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n         access_token = create_access_token(\n             data={\"sub\": user[\"email\"]},\n             expires_delta=access_token_expires\n         )\n-        \n+\n         logger.info(f\"‚úÖ Login exitoso para: {email}\")\n-        \n+\n         return LoginResponse(\n             access_token=access_token,\n             token_type=\"bearer\",\n-            username=user.get(\"username\"),\n+            username=user.get(\"username\"), # Usar .get() para evitar KeyError si el campo no existe\n             email=user[\"email\"],\n-            voice_url=user.get(\"voice_url\")\n+            voice_url=user.get(\"voice_url\"),\n+            face_url=user.get(\"face_url\") # Incluir face_url en la respuesta de login\n         )\n-        \n+\n+    except HTTPException:\n+        raise\n     except Exception as e:\n         logger.error(f\"‚ùå Error en el login: {str(e)}\")\n-        if isinstance(e, HTTPException):\n-            raise\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n         raise HTTPException(\n             status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n             detail=f\"Error en el login: {str(e)}\"\n         )\n@@ -348,168 +456,211 @@\n     voice_recording: UploadFile = File(...)\n ):\n     # Inicializar variable para evitar error de referencia\n     temp_file = None\n-    \n+\n     try:\n         logger.info(f\"üé§ Intento de login con voz para: {email}\")\n-        \n+\n         # Verificar tama√±o del archivo\n+        # Leer el contenido una vez para verificar el tama√±o y luego usarlo\n         content = await voice_recording.read()\n-        if len(content) > 15 * 1024 * 1024:  # 15MB\n-            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n+        content_size = len(content)\n+\n+        if content_size > 15 * 1024 * 1024:  # 15MB\n+            logger.warning(f\"‚ùå Archivo demasiado grande: {content_size} bytes\")\n             raise HTTPException(status_code=400, detail=\"El archivo de audio es demasiado grande (m√°ximo 15MB)\")\n-            \n-        if len(content) == 0:\n+\n+        if content_size == 0:\n             logger.warning(\"‚ùå Archivo vac√≠o\")\n             raise HTTPException(status_code=400, detail=\"El archivo de audio est√° vac√≠o\")\n-        \n+\n         # Buscar usuario por email\n+        # Aseg√∫rate de que get_user_by_email retorna un diccionario\n         user = mongo_client.get_user_by_email(email)\n         if not user:\n             logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n             raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n \n-        # Verificar que el usuario tenga una voz registrada\n-        if not user.get('voice_url'):\n-            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene voz registrada\")\n-            raise HTTPException(status_code=400, detail=\"No hay voz registrada para este usuario\")\n+        # Verificar que el usuario tenga una voz registrada (URL o embeddings)\n+        if not user.get('voice_url') and not user.get('voice_embedding') and not user.get('voice_embeddings'):\n+             logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene datos de voz registrados\")\n+             raise HTTPException(status_code=400, detail=\"No hay datos de voz registrados para este usuario\")\n \n-        logger.info(f\"üîç Voice URL del usuario: {user['voice_url']}\")\n-        \n-        # Verificar si el usuario tiene embeddings de voz registrados\n-        if not user.get('voice_embedding') and not user.get('voice_embeddings'):\n-            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene embeddings de voz registrados\")\n-            raise HTTPException(status_code=400, detail=\"No hay datos de voz registrados para este usuario\")\n-            \n+\n         # Crear directorio temporal\n         temp_dir = \"./temp_files\"\n         if not os.path.exists(temp_dir):\n             os.makedirs(temp_dir)\n-            \n+\n         # Guardar el archivo temporal de la grabaci√≥n\n-        temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n-        with open(temp_file, \"wb\") as buffer:\n-            buffer.write(content)\n-            logger.info(f\"üíæ Archivo de voz guardado: {temp_file} ({len(content)} bytes)\")\n-        \n-        # Importamos verify_voice (usando una instancia temporal del router)\n-        from voice_processing import verify_voice as voice_verifier\n-        \n+        with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{voice_recording.filename}\") as tmp:\n+            temp_file = tmp.name\n+            tmp.write(content) # Escribir el contenido ya le√≠do\n+            logger.info(f\"üíæ Archivo de voz guardado: {temp_file} ({content_size} bytes)\")\n+\n+\n+        # Importamos verify_voice (usando una instancia temporal del router) - Esto parece incorrecto.\n+        # verify_voice deber√≠a ser una funci√≥n o clase importada directamente.\n+        # from voice_processing import verify_voice as voice_verifier # Esto importa la funci√≥n, no una instancia de router\n+\n         # Preprocesar audio y extraer embedding\n+        # Aseg√∫rate de que estas funciones est√©n correctamente definidas en voice_processing.py\n         from voice_processing import preprocess_audio, extract_embedding\n-        \n+\n         try:\n             # Preprocesar audio\n+            # Aseg√∫rate de que preprocess_audio maneje el path correctamente\n             preprocess_audio(temp_file)\n-            \n+\n             # Extraer embedding\n+            # Aseg√∫rate de que extract_embedding maneje el path correctamente y retorne un numpy array o None\n             input_embedding = extract_embedding(temp_file)\n-            \n+\n             if input_embedding is None:\n+                logger.warning(\"‚ùå No se pudo extraer el embedding de la voz del audio recibido.\")\n                 raise HTTPException(\n                     status_code=400,\n                     detail=\"No se pudo procesar el audio. Intente nuevamente en un entorno m√°s silencioso.\"\n                 )\n-                \n+\n             # Obtener embeddings del usuario desde MongoDB\n-            user_data = mongo_client.get_user_voice_data(email)\n-            \n+            # Aseg√∫rate de que get_user_voice_data retorna un diccionario con 'voice_embedding' y 'voice_embeddings'\n+            user_voice_data = mongo_client.get_user_voice_data(email)\n+\n             # Verificar contra m√∫ltiples embeddings y tomar el mejor resultado\n             best_similarity = 0\n             is_match = False\n-            \n-            # Verificar contra la galer√≠a de embeddings si existe\n-            for stored_embedding in user_data.get('voice_embeddings', []):\n-                from voice_processing import compare_voices\n-                result = compare_voices(input_embedding, stored_embedding)\n-                if result[\"similarity\"] > best_similarity:\n-                    best_similarity = result[\"similarity\"]\n-                    is_match = result[\"match\"]\n-                    \n-            # Si no hay galer√≠a, verificar con el embedding principal\n-            if not user_data.get('voice_embeddings') and user_data.get('voice_embedding'):\n-                from voice_processing import compare_voices\n-                result = compare_voices(input_embedding, user_data['voice_embedding'])\n-                best_similarity = result[\"similarity\"]\n-                is_match = result[\"match\"]\n-            \n-            # Verificar si la voz coincide\n-            if not is_match:\n+\n+            # Convertir embeddings almacenados (si son listas) a numpy arrays para la comparaci√≥n\n+            stored_embeddings = user_voice_data.get('voice_embeddings', [])\n+            if user_voice_data.get('voice_embedding') is not None:\n+                 # Si hay un embedding principal y no hay lista, usarlo\n+                 if not stored_embeddings:\n+                      stored_embeddings = [user_voice_data['voice_embedding']]\n+                 else:\n+                      # Si hay lista y embedding principal, a√±adir el principal a la lista si no est√° ya\n+                      # Esto depende de tu l√≥gica de almacenamiento\n+                      pass # Opcional: A√±adir el embedding principal a stored_embeddings si no est√°\n+\n+\n+            # Asegurarse de que los embeddings almacenados son numpy arrays antes de comparar\n+            processed_stored_embeddings = []\n+            for emb in stored_embeddings:\n+                 if isinstance(emb, list):\n+                      processed_stored_embeddings.append(np.array(emb))\n+                 elif isinstance(emb, np.ndarray):\n+                      processed_stored_embeddings.append(emb)\n+                 # Manejar otros tipos si es necesario\n+\n+\n+            # Verificar contra la galer√≠a de embeddings procesados\n+            if processed_stored_embeddings:\n+                from voice_processing import compare_voices # Aseg√∫rate de que compare_voices est√© aqu√≠\n+                for stored_embedding_np in processed_stored_embeddings:\n+                    result = compare_voices(input_embedding, stored_embedding_np)\n+                    if result[\"similarity\"] > best_similarity:\n+                        best_similarity = result[\"similarity\"]\n+                        is_match = result[\"match\"]\n+\n+            # Si no se encontr√≥ ning√∫n embedding almacenado v√°lido\n+            if not processed_stored_embeddings:\n+                 logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene embeddings de voz v√°lidos almacenados.\")\n+                 raise HTTPException(status_code=400, detail=\"No hay datos de voz v√°lidos registrados para este usuario\")\n+\n+\n+            # Verificar si la voz coincide (usando el mejor resultado de similitud)\n+            # Aseg√∫rate de que VOICE_SIMILARITY_THRESHOLD est√© importado y sea un valor num√©rico\n+            if not is_match or best_similarity < VOICE_SIMILARITY_THRESHOLD:\n                 logger.warning(f\"‚ùå Similitud insuficiente: {best_similarity:.2f} < {VOICE_SIMILARITY_THRESHOLD}\")\n                 raise HTTPException(status_code=401, detail=\"La voz no coincide\")\n-            \n+\n             # Si llegamos aqu√≠, la voz coincide\n             logger.info(f\"‚úÖ Login exitoso para {email} con similitud {best_similarity:.2f}\")\n-            \n+\n             # Crear token\n             access_token = create_access_token(data={\"sub\": email})\n-            \n+\n+            # Aseg√∫rate de que user es un diccionario y contiene los campos necesarios\n             return LoginResponse(\n                 access_token=access_token,\n                 token_type=\"bearer\",\n                 username=user.get(\"username\"),\n-                email=email,\n-                voice_url=user.get(\"voice_url\")\n+                email=user[\"email\"],\n+                voice_url=user.get(\"voice_url\"),\n+                face_url=user.get(\"face_url\") # Incluir face_url\n             )\n-            \n+\n         except HTTPException:\n             raise\n         except Exception as e:\n-            logger.error(f\"‚ùå Error al procesar la voz: {str(e)}\")\n+            logger.error(f\"‚ùå Error durante el procesamiento o comparaci√≥n de voz: {str(e)}\")\n+            import traceback\n+            logger.error(f\"Stack trace: {traceback.format_exc()}\")\n             raise HTTPException(\n                 status_code=500,\n-                detail=\"Error al procesar la voz\"\n+                detail=\"Error al procesar la voz\" # Mensaje gen√©rico para el frontend\n             )\n \n     except HTTPException:\n         raise\n     except Exception as e:\n-        logger.error(f\"‚ùå Error en login con voz: {str(e)}\")\n+        logger.error(f\"‚ùå Error general en login con voz: {str(e)}\")\n         import traceback\n         logger.error(f\"Stack trace: {traceback.format_exc()}\")\n         raise HTTPException(\n             status_code=500,\n-            detail=\"Error al procesar la autenticaci√≥n por voz\"\n+            detail=\"Error al procesar la autenticaci√≥n por voz\" # Mensaje gen√©rico para el frontend\n         )\n     finally:\n         # Limpiar archivos temporales\n         if temp_file and os.path.exists(temp_file):\n             try:\n                 os.remove(temp_file)\n-                logger.debug(\"üßπ Archivo temporal eliminado\")\n+                logger.debug(f\"üßπ Archivo temporal de voz eliminado: {temp_file}\")\n             except Exception as e:\n-                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal: {str(e)}\")\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de voz {temp_file}: {str(e)}\")\n \n+\n @router.get(\"/me\", response_model=LoginResponse)\n async def read_users_me(current_user: dict = Depends(get_current_user)):\n+    # get_current_user debe retornar un diccionario con los datos del usuario\n+    # Aseg√∫rate de que current_user contiene 'email', 'username', 'voice_url', 'face_url'\n     return LoginResponse(\n-        access_token=\"\",\n+        access_token=\"\", # No retornamos el token de acceso aqu√≠ por seguridad (ya lo tiene el frontend)\n         token_type=\"bearer\",\n         username=current_user.get(\"username\"),\n-        email=current_user[\"email\"],\n-        voice_url=current_user.get(\"voice_url\")\n+        email=current_user[\"email\"], # El email debe estar siempre presente si el usuario est√° autenticado\n+        voice_url=current_user.get(\"voice_url\"),\n+        face_url=current_user.get(\"face_url\")\n     )\n \n @router.post(\"/login_face\", response_model=LoginResponse)\n async def login_face(\n     email: str = Form(...),\n     face_photo: UploadFile = File(...)\n ):\n+    # Inicializar variables para limpieza final\n+    temp_file_received = None\n+    temp_file_registered = None\n+\n     try:\n         logger.info(f\"üì∏ Intento de login con foto para: {email}\")\n-        \n+\n         # Verificar tama√±o del archivo\n         content = await face_photo.read()\n-        if len(content) > 5 * 1024 * 1024:  # 5MB\n-            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n+        content_size = len(content)\n+\n+        if content_size > 5 * 1024 * 1024:  # 5MB\n+            logger.warning(f\"‚ùå Archivo demasiado grande: {content_size} bytes\")\n             raise HTTPException(status_code=400, detail=\"La foto es demasiado grande (m√°ximo 5MB)\")\n-            \n-        if len(content) == 0:\n+\n+        if content_size == 0:\n             logger.warning(\"‚ùå Archivo vac√≠o\")\n             raise HTTPException(status_code=400, detail=\"La foto est√° vac√≠a\")\n-        \n+\n         # Buscar usuario por email\n+        # Aseg√∫rate de que get_user_by_email retorna un diccionario\n         user = mongo_client.get_user_by_email(email)\n         if not user:\n             logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n             raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n@@ -519,50 +670,54 @@\n             logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene foto registrada\")\n             raise HTTPException(status_code=400, detail=\"No hay foto registrada para este usuario\")\n \n         logger.info(f\"üîç Face URL del usuario: {user['face_url']}\")\n-        \n+\n         # Crear directorio temporal\n         temp_dir = \"./temp_files\"\n         if not os.path.exists(temp_dir):\n             os.makedirs(temp_dir)\n-            \n+\n         # Guardar el archivo temporal de la foto recibida\n-        temp_file_received = f\"{temp_dir}/temp_{face_photo.filename}\"\n-        with open(temp_file_received, \"wb\") as buffer:\n-            buffer.write(content)\n-            logger.info(f\"Foto recibida guardada: {temp_file_received} ({len(content)} bytes)\")\n+        with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{face_photo.filename}\") as tmp:\n+            temp_file_received = tmp.name\n+            tmp.write(content) # Escribir el contenido ya le√≠do\n+            logger.info(f\"Foto recibida guardada: {temp_file_received} ({content_size} bytes)\")\n \n         # Descargar la foto registrada\n         temp_file_registered = download_image(user['face_url'])\n-        if not temp_file_registered:\n+        if not temp_file_registered or not os.path.exists(temp_file_registered):\n+            logger.error(f\"‚ùå No se pudo descargar o encontrar la foto registrada para {email}\")\n             raise HTTPException(status_code=500, detail=\"Error al descargar la foto registrada\")\n \n         logger.info(\"üîÑ Iniciando comparaci√≥n facial...\")\n-        \n+\n         # Realizar la comparaci√≥n facial\n         match, similarity, exec_time = compare_faces_arcface(temp_file_received, temp_file_registered)\n-        \n+\n         logger.info(f\"üìä Resultados de la comparaci√≥n:\")\n         logger.info(f\"   - Coincidencia: {match}\")\n         logger.info(f\"   - Similitud: {similarity:.2f}%\")\n         logger.info(f\"   - Tiempo de ejecuci√≥n: {exec_time:.2f} segundos\")\n \n-        # Limpiar archivos temporales\n-        if os.path.exists(temp_file_received):\n-            os.remove(temp_file_received)\n-        if os.path.exists(temp_file_registered):\n-            os.remove(temp_file_registered)\n-            \n+        # Limpiar archivos temporales de inmediato (antes de la verificaci√≥n 'match')\n+        # Ya usamos finally para esto, as√≠ que no es estrictamente necesario aqu√≠, pero puede ayudar a liberar espacio antes.\n+        # if os.path.exists(temp_file_received):\n+        #     os.remove(temp_file_received)\n+        # if os.path.exists(temp_file_registered):\n+        #     os.remove(temp_file_registered)\n+\n+\n         if match:\n             # Generar token de acceso\n             access_token = create_access_token(data={\"sub\": email})\n             logger.info(f\"‚úÖ Login exitoso para: {email}\")\n+            # Aseg√∫rate de que user es un diccionario y contiene los campos necesarios\n             return LoginResponse(\n                 access_token=access_token,\n                 token_type=\"bearer\",\n                 username=user.get(\"username\"),\n-                email=email,\n+                email=user[\"email\"],\n                 voice_url=user.get(\"voice_url\"),\n                 face_url=user.get(\"face_url\")\n             )\n         else:\n@@ -570,21 +725,63 @@\n             raise HTTPException(\n                 status_code=401,\n                 detail=\"La autenticaci√≥n facial fall√≥. Las caras no coinciden.\"\n             )\n-            \n+\n     except HTTPException:\n         raise\n     except Exception as e:\n         logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n         raise HTTPException(\n             status_code=500,\n             detail=\"Error al procesar la autenticaci√≥n por foto\"\n-        ) \n-    \n-# En daw_backend/auth.py o routes/user.py\n-@router.get(\"/user_by_email\")\n+        )\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_file_received and os.path.exists(temp_file_received):\n+            try:\n+                os.remove(temp_file_received)\n+                logger.debug(f\"üßπ Archivo temporal de foto recibida eliminado: {temp_file_received}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto recibida {temp_file_received}: {str(e)}\")\n+        if temp_file_registered and os.path.exists(temp_file_registered):\n+            try:\n+                os.remove(temp_file_registered)\n+                logger.debug(f\"üßπ Archivo temporal de foto registrada eliminado: {temp_file_registered}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto registrada {temp_file_registered}: {str(e)}\")\n+\n+\n+# --- ENDPOINT CORREGIDO user_by_email ---\n+@router.get(\"/user_by_email\", response_model=UserResponseModel) # <-- Usamos el modelo Pydantic aqu√≠\n async def user_by_email(email: str):\n-    user = mongo_client.get_user_by_email(email)\n-    if not user:\n+    \"\"\"\n+    Obtiene los datos b√°sicos de un usuario por su email.\n+    Retorna el ID del usuario como string.\n+    \"\"\"\n+    logger.info(f\"üì• GET /auth/user_by_email para email: {email}\")\n+    # Asumimos que mongo_client.get_user_by_email retorna un DICCIONARIO de PyMongo\n+    user_document = mongo_client.get_user_by_email(email)\n+\n+    if not user_document:\n+        logger.warning(f\"‚ùå Usuario no encontrado para email: {email}\")\n+        # FastAPI maneja esta excepci√≥n y retorna un 404\n         raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n-    return user\n+\n+    # Si user_document es un diccionario (el caso m√°s com√∫n con PyMongo find_one),\n+    # FastAPI y Pydantic (gracias a response_model y Config) autom√°ticamente:\n+    # 1. Validar√°n que el diccionario coincida con UserResponseModel.\n+    # 2. Mapear√°n '_id' del diccionario a 'id' del modelo.\n+    # 3. Serializar√°n el ObjectId del '_id' a su representaci√≥n string usando json_encoders={ObjectId: str}.\n+    # 4. Retornar√°n el JSON validado y serializado al frontend.\n+\n+    logger.info(f\"‚úÖ Usuario encontrado y listo para serializar: {email}\")\n+    return user_document # Retornamos el diccionario directamente, Pydantic har√° el resto\n+\n+\n+# Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n+# En tu archivo main.py o app.py:\n+# from .auth import router as auth_router # Ajusta la importaci√≥n seg√∫n tu estructura\n+# app.include_router(auth_router, prefix=\"/auth\")\n+\n"
                },
                {
                    "date": 1746120290655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,9 +302,9 @@\n                          voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n \n \n                         # Subir a Azure Storage\n-                        voice_url = await upload_voice_recording(temp_voice_file, email)\n+                    voice_url = await upload_voice_recording(temp_voice_file, email)\n                         if not voice_url:\n                             logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n                             # Continuar sin URL de voz, pero con embedding\n                         else:\n"
                },
                {
                    "date": 1746120318424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -296,15 +296,15 @@\n                     if voice_embedding is None:\n                         logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                         # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                     else:\n-                         # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n-                         # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n-                         voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n+                        # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n+                        # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n+                        voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n \n \n                         # Subir a Azure Storage\n-                    voice_url = await upload_voice_recording(temp_voice_file, email)\n+                        voice_url = await upload_voice_recording(temp_voice_file, email)\n                         if not voice_url:\n                             logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n                             # Continuar sin URL de voz, pero con embedding\n                         else:\n"
                },
                {
                    "date": 1746120455987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,8 +114,9 @@\n         # Configuraci√≥n para Pydantic V2+\n         populate_by_name = True # Permite mapear por alias ('_id' a 'id')\n \n         # Configuraci√≥n para serializar ObjectId a string\n+        # Aunque definimos esto, a√±adiremos una conversi√≥n expl√≠cita abajo como respaldo\n         json_encoders = {ObjectId: str} # Para Pydantic V1 y V2\n \n         # Para Pydantic V2+, tambi√©n puedes a√±adir ejemplos para la documentaci√≥n\n         # json_schema_extra = {\n@@ -296,11 +297,11 @@\n                     if voice_embedding is None:\n                         logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                         # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                     else:\n-                        # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n-                        # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n-                        voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n+                         # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n+                         # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n+                         voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n \n \n                         # Subir a Azure Storage\n                         voice_url = await upload_voice_recording(temp_voice_file, email)\n@@ -454,9 +455,9 @@\n async def login_with_voice(\n     email: str = Form(...),\n     voice_recording: UploadFile = File(...)\n ):\n-    # Inicializar variable para evitar error de referencia\n+    # Inicializar variable para limpieza final\n     temp_file = None\n \n     try:\n         logger.info(f\"üé§ Intento de login con voz para: {email}\")\n@@ -768,20 +769,25 @@\n         logger.warning(f\"‚ùå Usuario no encontrado para email: {email}\")\n         # FastAPI maneja esta excepci√≥n y retorna un 404\n         raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n \n-    # Si user_document es un diccionario (el caso m√°s com√∫n con PyMongo find_one),\n-    # FastAPI y Pydantic (gracias a response_model y Config) autom√°ticamente:\n-    # 1. Validar√°n que el diccionario coincida con UserResponseModel.\n-    # 2. Mapear√°n '_id' del diccionario a 'id' del modelo.\n-    # 3. Serializar√°n el ObjectId del '_id' a su representaci√≥n string usando json_encoders={ObjectId: str}.\n-    # 4. Retornar√°n el JSON validado y serializado al frontend.\n+    # --- EXPLICIT CONVERSION TO STRING ---\n+    # This is a fallback in case json_encoders is not working as expected\n+    if isinstance(user_document, dict) and '_id' in user_document and isinstance(user_document['_id'], ObjectId):\n+        user_document['_id'] = str(user_document['_id'])\n+        logger.debug(f\"DEBUG BACKEND: Converted ObjectId to string for _id: {user_document['_id']}\")\n+    # Note: If user_document is not a dict but some custom object, this check needs adjustment.\n+    # Assuming it's a dict based on typical PyMongo find_one results.\n+    # ------------------------------------\n \n+\n     logger.info(f\"‚úÖ Usuario encontrado y listo para serializar: {email}\")\n-    return user_document # Retornamos el diccionario directamente, Pydantic har√° el resto\n+    # Return the potentially modified dictionary\n+    # Pydantic will still validate against UserResponseModel,\n+    # but _id should now be a string, matching the 'id: str' field.\n+    return user_document\n \n \n # Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n # En tu archivo main.py o app.py:\n # from .auth import router as auth_router # Ajusta la importaci√≥n seg√∫n tu estructura\n # app.include_router(auth_router, prefix=\"/auth\")\n-\n"
                },
                {
                    "date": 1746120475232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -299,9 +299,9 @@\n                         # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                     else:\n                          # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n                          # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n-                         voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n+                        voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n \n \n                         # Subir a Azure Storage\n                         voice_url = await upload_voice_recording(temp_voice_file, email)\n"
                },
                {
                    "date": 1746140789678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,8 +43,10 @@\n from urllib.parse import urlparse\n import tempfile\n import traceback # Para imprimir stack trace en errores\n \n+# importar el router para los ejercicios\n+from routers import logic as logic_router\n # Configurar logging\n logging.basicConfig(\n     level=logging.INFO if IS_PRODUCTION else logging.DEBUG,\n     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n@@ -59,8 +61,9 @@\n logger.info(f\"Ejecutando en entorno: {ENVIRONMENT}\")\n \n router = APIRouter()\n mongo_client = MongoDBClient()\n+app.include_router(logic_router, prefix=\"/api\") #a√±adimos el router para los ejercicios\n \n # ----- Configurar CORS (Aseg√∫rate de que ALLOWED_ORIGINS no contenga \"*\" si allow_credentials es True) -----\n CORS_CONFIG = {\n     \"allow_origins\": ALLOWED_ORIGINS, # Debe contener las URLs exactas de tu frontend (ej: [\"http://localhost:5173\", \"https://daw-frontend.vercel.app\"])\n"
                },
                {
                    "date": 1746140822436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -733,5 +733,64 @@\n \n     except HTTPException:\n         raise\n     except Exception as e:\n-        logger.error(f\"‚ùå Error e\n\\ No newline at end of file\n+        logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+        raise HTTPException(\n+            status_code=500,\n+            detail=\"Error al procesar la autenticaci√≥n por foto\"\n+        )\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_file_received and os.path.exists(temp_file_received):\n+            try:\n+                os.remove(temp_file_received)\n+                logger.debug(f\"üßπ Archivo temporal de foto recibida eliminado: {temp_file_received}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto recibida {temp_file_received}: {str(e)}\")\n+        if temp_file_registered and os.path.exists(temp_file_registered):\n+            try:\n+                os.remove(temp_file_registered)\n+                logger.debug(f\"üßπ Archivo temporal de foto registrada eliminado: {temp_file_registered}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto registrada {temp_file_registered}: {str(e)}\")\n+\n+\n+# --- ENDPOINT CORREGIDO user_by_email ---\n+@router.get(\"/user_by_email\", response_model=UserResponseModel) # <-- Usamos el modelo Pydantic aqu√≠\n+async def user_by_email(email: str):\n+    \"\"\"\n+    Obtiene los datos b√°sicos de un usuario por su email.\n+    Retorna el ID del usuario como string.\n+    \"\"\"\n+    logger.info(f\"üì• GET /auth/user_by_email para email: {email}\")\n+    # Asumimos que mongo_client.get_user_by_email retorna un DICCIONARIO de PyMongo\n+    user_document = mongo_client.get_user_by_email(email)\n+\n+    if not user_document:\n+        logger.warning(f\"‚ùå Usuario no encontrado para email: {email}\")\n+        # FastAPI maneja esta excepci√≥n y retorna un 404\n+        raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n+\n+    # --- EXPLICIT CONVERSION TO STRING ---\n+    # This is a fallback in case json_encoders is not working as expected\n+    if isinstance(user_document, dict) and '_id' in user_document and isinstance(user_document['_id'], ObjectId):\n+        user_document['_id'] = str(user_document['_id'])\n+        logger.debug(f\"DEBUG BACKEND: Converted ObjectId to string for _id: {user_document['_id']}\")\n+    # Note: If user_document is not a dict but some custom object, this check needs adjustment.\n+    # Assuming it's a dict based on typical PyMongo find_one results.\n+    # ------------------------------------\n+\n+\n+    logger.info(f\"‚úÖ Usuario encontrado y listo para serializar: {email}\")\n+    # Return the potentially modified dictionary\n+    # Pydantic will still validate against UserResponseModel,\n+    # but _id should now be a string, matching the 'id: str' field.\n+    return user_document\n+\n+\n+# Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n+# En tu archivo main.py o app.py:\n+# from .auth import router as auth_router # Ajusta la importaci√≥n seg√∫n tu estructura\n+# app.include_router(auth_router, prefix=\"/auth\")\n"
                },
                {
                    "date": 1746140983636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,796 @@\n+from fastapi import APIRouter, HTTPException, Depends, status, UploadFile, File, Form\n+from fastapi.security import OAuth2PasswordRequestForm\n+from fastapi.responses import JSONResponse\n+from datetime import timedelta\n+from typing import Optional, Dict, List # Importar List si voice_embeddings es una lista\n+import logging\n+import hashlib\n+import os\n+from utils.auth_utils import create_access_token, get_current_user\n+# Aseg√∫rate de que la importaci√≥n de MongoDBClient sea correcta para tu estructura de proyecto\n+from mongodb_client import MongoDBClient\n+# Aseg√∫rate de que las importaciones de voice_processing sean correctas\n+from voice_processing import extract_embedding, compare_voices, verify_voice, preprocess_audio\n+# Aseg√∫rate de que las importaciones de azure_storage sean correctas\n+from azure_storage import upload_voice_recording, download_voice_recording, ensure_azure_storage, upload_face_photo\n+# Aseg√∫rate de que la importaci√≥n de config sea correcta\n+from config import (\n+    SECRET_KEY,\n+    ACCESS_TOKEN_EXPIRE_MINUTES,\n+    VOICE_SIMILARITY_THRESHOLD,\n+    ENVIRONMENT,\n+    IS_PRODUCTION,\n+    ALLOWED_ORIGINS # Importar ALLOWED_ORIGINS para la config de CORS\n+)\n+# Importaciones para Pydantic y BSON\n+from pydantic import BaseModel, Field\n+from bson import ObjectId # Necesario para la serializaci√≥n de ObjectId\n+from fastapi.middleware.cors import CORSMiddleware # Importar CORSMiddleware\n+\n+# Otras importaciones que ya ten√≠as\n+import librosa\n+import numpy as np\n+import face_recognition\n+import cv2\n+import time\n+import warnings\n+import onnxruntime as ort\n+# Aseg√∫rate de que la importaci√≥n de face_model sea correcta\n+from face_model import face_analyzer\n+import contextlib\n+import io\n+import requests\n+from urllib.parse import urlparse\n+import tempfile\n+import traceback # Para imprimir stack trace en errores\n+\n+# importar el router para los ejercicios\n+from routers.logic import router as logic_router\n+# Configurar logging\n+logging.basicConfig(\n+    level=logging.INFO if IS_PRODUCTION else logging.DEBUG,\n+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n+    handlers=[\n+        logging.StreamHandler(),\n+        logging.FileHandler('auth.log') # Considera usar logging.FileHandler con un path absoluto o relativo seguro\n+    ]\n+)\n+logger = logging.getLogger(__name__)\n+\n+# Log del entorno actual\n+logger.info(f\"Ejecutando en entorno: {ENVIRONMENT}\")\n+\n+router = APIRouter()\n+mongo_client = MongoDBClient()\n+router.include_router(logic_router, prefix=\"/api\") #a√±adimos el router para los ejercicios\n+\n+# ----- Configurar CORS (Aseg√∫rate de que ALLOWED_ORIGINS no contenga \"*\" si allow_credentials es True) -----\n+CORS_CONFIG = {\n+    \"allow_origins\": ALLOWED_ORIGINS, # Debe contener las URLs exactas de tu frontend (ej: [\"http://localhost:5173\", \"https://daw-frontend.vercel.app\"])\n+    \"allow_credentials\": True, # Necesario si tu frontend env√≠a cookies o headers de Authorization\n+    \"allow_methods\": [\"*\"], # O especifica solo los m√©todos que usas (GET, POST, OPTIONS, etc.)\n+    \"allow_headers\": [\"*\"], # O especifica solo los headers que usas (Authorization, Content-Type, etc.)\n+}\n+\n+# Asumiendo que 'app' es tu instancia principal de FastAPI definida en otro lugar (ej: main.py)\n+# Debes a√±adir este middleware a tu instancia principal de FastAPI, no necesariamente aqu√≠\n+# app.add_middleware(\n+#     CORSMiddleware,\n+#     **CORS_CONFIG\n+# )\n+# Si este archivo es solo el router, la configuraci√≥n de CORS debe estar en el archivo principal de la app FastAPI.\n+\n+\n+# ----- Definici√≥n de Modelos Pydantic -----\n+\n+class Token(BaseModel):\n+    access_token: str\n+    token_type: str\n+\n+class TokenData(BaseModel):\n+    username: Optional[str] = None\n+    email: str\n+    voice_url: Optional[str] = None\n+\n+class LoginResponse(BaseModel):\n+    access_token: str\n+    token_type: str\n+    username: Optional[str] = None\n+    email: str\n+    voice_url: Optional[str] = None\n+    face_url: Optional[str] = None\n+\n+# --- NUEVO MODELO PARA LA RESPUESTA DEL ENDPOINT user_by_email ---\n+class UserResponseModel(BaseModel):\n+    # Mapea el campo '_id' de MongoDB (ObjectId) a 'id' en el modelo y JSON\n+    id: str = Field(alias='_id')\n+\n+    # A√±ade aqu√≠ los otros campos del usuario que quieres retornar\n+    email: str\n+    username: Optional[str] = None # Asumiendo que username puede ser opcional\n+\n+    # A√±ade otros campos si tu documento de usuario los tiene y quieres retornarlos\n+    # voice_url: Optional[str] = None\n+    # face_url: Optional[str] = None\n+\n+    class Config:\n+        # Configuraci√≥n para Pydantic V2+\n+        populate_by_name = True # Permite mapear por alias ('_id' a 'id')\n+\n+        # Configuraci√≥n para serializar ObjectId a string\n+        # Aunque definimos esto, a√±adiremos una conversi√≥n expl√≠cita abajo como respaldo\n+        json_encoders = {ObjectId: str} # Para Pydantic V1 y V2\n+\n+        # Para Pydantic V2+, tambi√©n puedes a√±adir ejemplos para la documentaci√≥n\n+        # json_schema_extra = {\n+        #     \"examples\": [\n+        #         {\n+        #             \"id\": \"60d5ec49b8f9c40e6c1a0d9e\",\n+        #             \"email\": \"test@example.com\",\n+        #             \"username\": \"testuser\"\n+        #         }\n+        #     ]\n+        # }\n+\n+\n+# Suprimir warnings molestos\n+warnings.filterwarnings(\"ignore\")\n+\n+# Silenciar logs internos de onnxruntime\n+ort.set_default_logger_severity(3)\n+\n+# ------------------ PREPROCESAMIENTO ------------------ #\n+def preprocess_image(image):\n+    height, width = image.shape[:2]\n+    max_size = 800\n+    if height > max_size or width > max_size:\n+        scale = max_size / max(height, width)\n+        image = cv2.resize(image, (int(width * scale), int(height * scale)))\n+\n+    lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)\n+    l, a, b = cv2.split(lab)\n+    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n+    l = clahe.apply(l)\n+    lab = cv2.merge((l, a, b))\n+    enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n+\n+    return enhanced\n+\n+# ------------------ ARCFACE COMPARISON ------------------ #\n+def compare_faces_arcface(image_path1, image_path2, threshold=0.65):\n+    if not os.path.exists(image_path1) or not os.path.exists(image_path2):\n+        logger.error(\"One or both image files do not exist\")\n+        return \"One or both image files do not exist\", None, None\n+\n+    start_time = time.time()\n+\n+    img1 = cv2.imread(image_path1)\n+    img2 = cv2.imread(image_path2)\n+\n+    if img1 is None or img2 is None:\n+        logger.error(\"Error loading one or both images\")\n+        return \"Error loading one or both images\", None, None\n+\n+    img1_rgb = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)\n+    img2_rgb = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)\n+\n+    img1_processed = preprocess_image(img1_rgb)\n+    img2_processed = preprocess_image(img2_rgb)\n+\n+    # Silenciar los prints del modelo durante su inicializaci√≥n\n+    # Esto parece ser un remanente de depuraci√≥n, considera eliminarlo si no es necesario\n+    # f = io.StringIO()\n+    # with contextlib.redirect_stdout(f):\n+    faces1 = face_analyzer.get(cv2.cvtColor(img1_processed, cv2.COLOR_RGB2BGR))\n+    faces2 = face_analyzer.get(cv2.cvtColor(img2_processed, cv2.COLOR_RGB2BGR))\n+\n+\n+    if not faces1 or not faces2:\n+        logger.warning(\"No faces detected in one or both images\")\n+        return \"No faces detected in one or both images\", None, None\n+\n+    embedding1 = faces1[0].embedding\n+    embedding2 = faces2[0].embedding\n+\n+    cosine_sim = np.dot(embedding1, embedding2) / (np.linalg.norm(embedding1) * np.linalg.norm(embedding2))\n+    similarity_percentage = cosine_sim * 100\n+    match = cosine_sim >= threshold\n+\n+    execution_time = time.time() - start_time\n+    logger.debug(f\"Face comparison done in {execution_time:.4f} seconds\")\n+\n+    return match, similarity_percentage, execution_time\n+\n+# Funci√≥n para descargar imagen desde URL\n+def download_image(url):\n+    try:\n+        response = requests.get(url)\n+        if response.status_code == 200:\n+            # Crear un archivo temporal\n+            # Usar delete=False para que el archivo no se elimine inmediatamente al cerrarse\n+            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')\n+            temp_file.write(response.content)\n+            temp_file.close() # Cerrar el archivo para poder usar su nombre\n+            logger.debug(f\"Downloaded image to temporary file: {temp_file.name}\")\n+            return temp_file.name\n+        else:\n+            logger.error(f\"Error downloading image from {url}: Status code {response.status_code}\")\n+            return None\n+    except Exception as e:\n+        logger.error(f\"Error downloading image: {str(e)}\")\n+        return None\n+\n+@router.post(\"/register\", response_model=LoginResponse)\n+async def register(\n+    email: str = Form(...),\n+    username: str = Form(...),\n+    password: str = Form(...),\n+    voice_recording: UploadFile = File(None),\n+    face_photo: UploadFile = File(None)\n+):\n+    # Inicializar variables para limpieza final\n+    temp_voice_file = None\n+    temp_face_file = None\n+\n+    try:\n+        logger.info(f\"Intento de registro para: {email}\")\n+\n+        # Verificar si el usuario ya existe\n+        existing_user = mongo_client.get_user_by_email(email)\n+        if existing_user:\n+            logger.warning(f\"Intento de registro con email ya existente: {email}\")\n+            raise HTTPException(status_code=400, detail=\"El email ya est√° registrado\")\n+\n+        # Hashear la contrase√±a\n+        hashed_password = hashlib.sha256(password.encode()).hexdigest()\n+        logger.debug(f\"Contrase√±a hasheada para: {email}\")\n+\n+        # Procesar la grabaci√≥n de voz si se proporciona\n+        voice_embedding = None\n+        voice_embeddings = None # Considera si quieres almacenar m√∫ltiples embeddings al registrar\n+        voice_url = None\n+\n+        if voice_recording:\n+            logger.info(\"Procesando grabaci√≥n de voz\")\n+            logger.info(f\"Nombre del archivo: {voice_recording.filename}\")\n+            logger.info(f\"Tipo de contenido: {voice_recording.content_type}\")\n+\n+            # Verificar disponibilidad de Azure Storage si se va a subir una grabaci√≥n\n+            if not await ensure_azure_storage():\n+                logger.warning(\"‚ö†Ô∏è Azure Storage no est√° disponible. El usuario se registrar√° sin voz.\")\n+                # No lanzamos excepci√≥n para permitir el registro sin voz\n+            else:\n+                # Crear directorio temporal\n+                temp_dir = \"./temp_files\"\n+                if not os.path.exists(temp_dir):\n+                    os.makedirs(temp_dir)\n+\n+                # Guardar archivo temporalmente\n+                # Usar tempfile para nombres √∫nicos y manejo m√°s seguro\n+                with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{voice_recording.filename}\") as tmp:\n+                    temp_voice_file = tmp.name\n+                    content = await voice_recording.read()\n+                    if not content:\n+                        logger.error(\"‚ùå El archivo de voz est√° vac√≠o\")\n+                        raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n+\n+                    content_size = len(content)\n+                    logger.info(f\"Tama√±o del contenido: {content_size} bytes\")\n+                    tmp.write(content)\n+                    logger.info(f\"Archivo de voz guardado temporalmente: {temp_voice_file}\")\n+\n+                # Verificar que el archivo se escribi√≥ correctamente\n+                if os.path.exists(temp_voice_file):\n+                    file_size = os.path.getsize(temp_voice_file)\n+                    logger.info(f\"Tama√±o del archivo guardado: {file_size} bytes\")\n+                    if file_size == 0:\n+                        logger.error(\"‚ùå El archivo guardado est√° vac√≠o\")\n+                        raise HTTPException(status_code=400, detail=\"El archivo de voz guardado est√° vac√≠o\")\n+                else:\n+                    logger.error(\"‚ùå El archivo no se guard√≥ correctamente\")\n+                    raise HTTPException(status_code=500, detail=\"Error al guardar el archivo de voz\")\n+\n+\n+                # Extraer embedding\n+                try:\n+                    # Aseg√∫rate de que preprocess_audio maneje el path correctamente\n+                    preprocess_audio(temp_voice_file) # Preprocesar el archivo temporal\n+                    voice_embedding = extract_embedding(temp_voice_file) # Extraer del archivo temporal\n+\n+                    if voice_embedding is None:\n+                        logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n+                        # No falla el registro, simplemente se crea el usuario sin embedding de voz\n+                    else:\n+                         # Aqu√≠ podr√≠as decidir si guardar solo el √∫ltimo embedding o una lista\n+                         # Si quieres una lista, inicial√≠zala y a√±ade el embedding\n+                        voice_embeddings = [voice_embedding.tolist()] # Convertir a lista para guardar en MongoDB\n+\n+\n+                        # Subir a Azure Storage\n+                        voice_url = await upload_voice_recording(temp_voice_file, email)\n+                        if not voice_url:\n+                            logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n+                            # Continuar sin URL de voz, pero con embedding\n+                        else:\n+                            logger.info(f\"üì§ Archivo subido a Azure. URL: {voice_url}\")\n+                except Exception as e:\n+                     logger.error(f\"‚ùå Error durante el procesamiento o subida de voz: {str(e)}\")\n+                     # Considera si quieres lanzar una HTTPException aqu√≠ o simplemente loguear y continuar\n+                     # raise HTTPException(status_code=500, detail=\"Error al procesar o subir la grabaci√≥n de voz\")\n+\n+\n+        if face_photo:\n+            logger.info(\"Procesando foto de rostro\")\n+            # Crear directorio temporal\n+            temp_dir = \"./temp_files\"\n+            if not os.path.exists(temp_dir):\n+                os.makedirs(temp_dir)\n+\n+            # Guardar archivo temporalmente\n+            with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{face_photo.filename}\") as tmp:\n+                temp_face_file = tmp.name\n+                content = await face_photo.read()\n+                if not content:\n+                     logger.error(\"‚ùå El archivo de foto est√° vac√≠o\")\n+                     raise HTTPException(status_code=400, detail=\"El archivo de foto est√° vac√≠o\")\n+                tmp.write(content)\n+                logger.info(f\"Foto de rostro guardada temporalmente: {temp_face_file}\")\n+\n+            # Subir a Azure Storage\n+            face_url = await upload_face_photo(temp_face_file, email)\n+            if not face_url:\n+                logger.error(\"‚ùå No se pudo subir la foto de rostro a Azure Storage\")\n+                # Considera si quieres lanzar una HTTPException aqu√≠ o simplemente loguear y continuar\n+                # raise HTTPException(status_code=500, detail=\"Error al subir la foto de rostro\")\n+            else:\n+                logger.info(f\"üì§ Foto de rostro subida a Azure. URL: {face_url}\")\n+\n+\n+        # Crear usuario\n+        logger.info(\"Creando usuario en MongoDB\")\n+        # Aseg√∫rate de que create_user pueda manejar voice_embedding y voice_embeddings (lista)\n+        success = mongo_client.create_user(\n+            username=username,\n+            email=email,\n+            password=hashed_password,  # Usar la contrase√±a hasheada\n+            voice_embedding=voice_embedding.tolist() if voice_embedding is not None else None, # Guardar como lista si existe\n+            voice_embeddings=voice_embeddings, # Guardar la lista si se gener√≥\n+            voice_url=voice_url,\n+            face_url=face_url,\n+        )\n+\n+        if success:\n+            logger.info(f\"‚úÖ Usuario registrado exitosamente: {email}\")\n+            # Crear token de acceso\n+            access_token = create_access_token(data={\"sub\": email})\n+            return LoginResponse(\n+                access_token=access_token,\n+                token_type=\"bearer\",\n+                username=username,\n+                email=email,\n+                voice_url=voice_url,\n+                face_url=face_url,\n+            )\n+        else:\n+            logger.error(f\"‚ùå Error al crear usuario en la base de datos: {email}\")\n+            raise HTTPException(status_code=500, detail=\"Error al crear el usuario\")\n+\n+\n+    except HTTPException:\n+        # Si ya es una HTTPException, simplemente la relanzamos\n+        raise\n+    except Exception as e:\n+        # Para otros errores, logueamos el stack trace y retornamos un 500\n+        logger.error(f\"‚ùå Error al registrar usuario: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+        raise HTTPException(status_code=500, detail=\"Error en el servidor\")\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_voice_file and os.path.exists(temp_voice_file):\n+            try:\n+                os.remove(temp_voice_file)\n+                logger.debug(f\"üßπ Archivo temporal de voz eliminado: {temp_voice_file}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de voz {temp_voice_file}: {str(e)}\")\n+        if temp_face_file and os.path.exists(temp_face_file):\n+            try:\n+                os.remove(temp_face_file)\n+                logger.debug(f\"üßπ Archivo temporal de foto eliminado: {temp_face_file}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto {temp_face_file}: {str(e)}\")\n+\n+\n+@router.post(\"/login\", response_model=LoginResponse)\n+async def login(form_data: OAuth2PasswordRequestForm = Depends()):\n+    \"\"\"\n+    Inicia sesi√≥n con credenciales (usuario y contrase√±a)\n+    \"\"\"\n+    try:\n+        email = form_data.username  # En OAuth2PasswordRequestForm el email se env√≠a como username\n+        logger.info(f\"üîë Intento de inicio de sesi√≥n para: {email}\")\n+\n+        # Hashear la contrase√±a\n+        hashed_password = hashlib.sha256(form_data.password.encode()).hexdigest()\n+        logger.debug(f\"Contrase√±a hasheada para login: {email}\")\n+\n+        # Verificar credenciales\n+        # Aseg√∫rate de que verify_user_credentials retorna un diccionario con 'email', 'username', 'voice_url', etc.\n+        user = mongo_client.verify_user_credentials(email, hashed_password)\n+        if not user:\n+            logger.warning(f\"‚ùå Credenciales incorrectas para: {email}\")\n+            raise HTTPException(\n+                status_code=status.HTTP_401_UNAUTHORIZED,\n+                detail=\"Credenciales incorrectas\",\n+                headers={\"WWW-Authenticate\": \"Bearer\"},\n+            )\n+\n+        # Crear token\n+        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n+        access_token = create_access_token(\n+            data={\"sub\": user[\"email\"]},\n+            expires_delta=access_token_expires\n+        )\n+\n+        logger.info(f\"‚úÖ Login exitoso para: {email}\")\n+\n+        return LoginResponse(\n+            access_token=access_token,\n+            token_type=\"bearer\",\n+            username=user.get(\"username\"), # Usar .get() para evitar KeyError si el campo no existe\n+            email=user[\"email\"],\n+            voice_url=user.get(\"voice_url\"),\n+            face_url=user.get(\"face_url\") # Incluir face_url en la respuesta de login\n+        )\n+\n+    except HTTPException:\n+        raise\n+    except Exception as e:\n+        logger.error(f\"‚ùå Error en el login: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+        raise HTTPException(\n+            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n+            detail=f\"Error en el login: {str(e)}\"\n+        )\n+\n+@router.post(\"/login-voice\", response_model=LoginResponse)\n+async def login_with_voice(\n+    email: str = Form(...),\n+    voice_recording: UploadFile = File(...)\n+):\n+    # Inicializar variable para limpieza final\n+    temp_file = None\n+\n+    try:\n+        logger.info(f\"üé§ Intento de login con voz para: {email}\")\n+\n+        # Verificar tama√±o del archivo\n+        # Leer el contenido una vez para verificar el tama√±o y luego usarlo\n+        content = await voice_recording.read()\n+        content_size = len(content)\n+\n+        if content_size > 15 * 1024 * 1024:  # 15MB\n+            logger.warning(f\"‚ùå Archivo demasiado grande: {content_size} bytes\")\n+            raise HTTPException(status_code=400, detail=\"El archivo de audio es demasiado grande (m√°ximo 15MB)\")\n+\n+        if content_size == 0:\n+            logger.warning(\"‚ùå Archivo vac√≠o\")\n+            raise HTTPException(status_code=400, detail=\"El archivo de audio est√° vac√≠o\")\n+\n+        # Buscar usuario por email\n+        # Aseg√∫rate de que get_user_by_email retorna un diccionario\n+        user = mongo_client.get_user_by_email(email)\n+        if not user:\n+            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n+            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n+\n+        # Verificar que el usuario tenga una voz registrada (URL o embeddings)\n+        if not user.get('voice_url') and not user.get('voice_embedding') and not user.get('voice_embeddings'):\n+             logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene datos de voz registrados\")\n+             raise HTTPException(status_code=400, detail=\"No hay datos de voz registrados para este usuario\")\n+\n+\n+        # Crear directorio temporal\n+        temp_dir = \"./temp_files\"\n+        if not os.path.exists(temp_dir):\n+            os.makedirs(temp_dir)\n+\n+        # Guardar el archivo temporal de la grabaci√≥n\n+        with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{voice_recording.filename}\") as tmp:\n+            temp_file = tmp.name\n+            tmp.write(content) # Escribir el contenido ya le√≠do\n+            logger.info(f\"üíæ Archivo de voz guardado: {temp_file} ({content_size} bytes)\")\n+\n+\n+        # Importamos verify_voice (usando una instancia temporal del router) - Esto parece incorrecto.\n+        # verify_voice deber√≠a ser una funci√≥n o clase importada directamente.\n+        # from voice_processing import verify_voice as voice_verifier # Esto importa la funci√≥n, no una instancia de router\n+\n+        # Preprocesar audio y extraer embedding\n+        # Aseg√∫rate de que estas funciones est√©n correctamente definidas en voice_processing.py\n+        from voice_processing import preprocess_audio, extract_embedding\n+\n+        try:\n+            # Preprocesar audio\n+            # Aseg√∫rate de que preprocess_audio maneje el path correctamente\n+            preprocess_audio(temp_file)\n+\n+            # Extraer embedding\n+            # Aseg√∫rate de que extract_embedding maneje el path correctamente y retorne un numpy array o None\n+            input_embedding = extract_embedding(temp_file)\n+\n+            if input_embedding is None:\n+                logger.warning(\"‚ùå No se pudo extraer el embedding de la voz del audio recibido.\")\n+                raise HTTPException(\n+                    status_code=400,\n+                    detail=\"No se pudo procesar el audio. Intente nuevamente en un entorno m√°s silencioso.\"\n+                )\n+\n+            # Obtener embeddings del usuario desde MongoDB\n+            # Aseg√∫rate de que get_user_voice_data retorna un diccionario con 'voice_embedding' y 'voice_embeddings'\n+            user_voice_data = mongo_client.get_user_voice_data(email)\n+\n+            # Verificar contra m√∫ltiples embeddings y tomar el mejor resultado\n+            best_similarity = 0\n+            is_match = False\n+\n+            # Convertir embeddings almacenados (si son listas) a numpy arrays para la comparaci√≥n\n+            stored_embeddings = user_voice_data.get('voice_embeddings', [])\n+            if user_voice_data.get('voice_embedding') is not None:\n+                 # Si hay un embedding principal y no hay lista, usarlo\n+                 if not stored_embeddings:\n+                      stored_embeddings = [user_voice_data['voice_embedding']]\n+                 else:\n+                      # Si hay lista y embedding principal, a√±adir el principal a la lista si no est√° ya\n+                      # Esto depende de tu l√≥gica de almacenamiento\n+                      pass # Opcional: A√±adir el embedding principal a stored_embeddings si no est√°\n+\n+\n+            # Asegurarse de que los embeddings almacenados son numpy arrays antes de comparar\n+            processed_stored_embeddings = []\n+            for emb in stored_embeddings:\n+                 if isinstance(emb, list):\n+                      processed_stored_embeddings.append(np.array(emb))\n+                 elif isinstance(emb, np.ndarray):\n+                      processed_stored_embeddings.append(emb)\n+                 # Manejar otros tipos si es necesario\n+\n+\n+            # Verificar contra la galer√≠a de embeddings procesados\n+            if processed_stored_embeddings:\n+                from voice_processing import compare_voices # Aseg√∫rate de que compare_voices est√© aqu√≠\n+                for stored_embedding_np in processed_stored_embeddings:\n+                    result = compare_voices(input_embedding, stored_embedding_np)\n+                    if result[\"similarity\"] > best_similarity:\n+                        best_similarity = result[\"similarity\"]\n+                        is_match = result[\"match\"]\n+\n+            # Si no se encontr√≥ ning√∫n embedding almacenado v√°lido\n+            if not processed_stored_embeddings:\n+                 logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene embeddings de voz v√°lidos almacenados.\")\n+                 raise HTTPException(status_code=400, detail=\"No hay datos de voz v√°lidos registrados para este usuario\")\n+\n+\n+            # Verificar si la voz coincide (usando el mejor resultado de similitud)\n+            # Aseg√∫rate de que VOICE_SIMILARITY_THRESHOLD est√© importado y sea un valor num√©rico\n+            if not is_match or best_similarity < VOICE_SIMILARITY_THRESHOLD:\n+                logger.warning(f\"‚ùå Similitud insuficiente: {best_similarity:.2f} < {VOICE_SIMILARITY_THRESHOLD}\")\n+                raise HTTPException(status_code=401, detail=\"La voz no coincide\")\n+\n+            # Si llegamos aqu√≠, la voz coincide\n+            logger.info(f\"‚úÖ Login exitoso para {email} con similitud {best_similarity:.2f}\")\n+\n+            # Crear token\n+            access_token = create_access_token(data={\"sub\": email})\n+\n+            # Aseg√∫rate de que user es un diccionario y contiene los campos necesarios\n+            return LoginResponse(\n+                access_token=access_token,\n+                token_type=\"bearer\",\n+                username=user.get(\"username\"),\n+                email=user[\"email\"],\n+                voice_url=user.get(\"voice_url\"),\n+                face_url=user.get(\"face_url\") # Incluir face_url\n+            )\n+\n+        except HTTPException:\n+            raise\n+        except Exception as e:\n+            logger.error(f\"‚ùå Error durante el procesamiento o comparaci√≥n de voz: {str(e)}\")\n+            import traceback\n+            logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+            raise HTTPException(\n+                status_code=500,\n+                detail=\"Error al procesar la voz\" # Mensaje gen√©rico para el frontend\n+            )\n+\n+    except HTTPException:\n+        raise\n+    except Exception as e:\n+        logger.error(f\"‚ùå Error general en login con voz: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+        raise HTTPException(\n+            status_code=500,\n+            detail=\"Error al procesar la autenticaci√≥n por voz\" # Mensaje gen√©rico para el frontend\n+        )\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_file and os.path.exists(temp_file):\n+            try:\n+                os.remove(temp_file)\n+                logger.debug(f\"üßπ Archivo temporal de voz eliminado: {temp_file}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de voz {temp_file}: {str(e)}\")\n+\n+\n+@router.get(\"/me\", response_model=LoginResponse)\n+async def read_users_me(current_user: dict = Depends(get_current_user)):\n+    # get_current_user debe retornar un diccionario con los datos del usuario\n+    # Aseg√∫rate de que current_user contiene 'email', 'username', 'voice_url', 'face_url'\n+    return LoginResponse(\n+        access_token=\"\", # No retornamos el token de acceso aqu√≠ por seguridad (ya lo tiene el frontend)\n+        token_type=\"bearer\",\n+        username=current_user.get(\"username\"),\n+        email=current_user[\"email\"], # El email debe estar siempre presente si el usuario est√° autenticado\n+        voice_url=current_user.get(\"voice_url\"),\n+        face_url=current_user.get(\"face_url\")\n+    )\n+\n+@router.post(\"/login_face\", response_model=LoginResponse)\n+async def login_face(\n+    email: str = Form(...),\n+    face_photo: UploadFile = File(...)\n+):\n+    # Inicializar variables para limpieza final\n+    temp_file_received = None\n+    temp_file_registered = None\n+\n+    try:\n+        logger.info(f\"üì∏ Intento de login con foto para: {email}\")\n+\n+        # Verificar tama√±o del archivo\n+        content = await face_photo.read()\n+        content_size = len(content)\n+\n+        if content_size > 5 * 1024 * 1024:  # 5MB\n+            logger.warning(f\"‚ùå Archivo demasiado grande: {content_size} bytes\")\n+            raise HTTPException(status_code=400, detail=\"La foto es demasiado grande (m√°ximo 5MB)\")\n+\n+        if content_size == 0:\n+            logger.warning(\"‚ùå Archivo vac√≠o\")\n+            raise HTTPException(status_code=400, detail=\"La foto est√° vac√≠a\")\n+\n+        # Buscar usuario por email\n+        # Aseg√∫rate de que get_user_by_email retorna un diccionario\n+        user = mongo_client.get_user_by_email(email)\n+        if not user:\n+            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n+            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n+\n+        # Verificar que el usuario tenga una foto registrada\n+        if not user.get('face_url'):\n+            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene foto registrada\")\n+            raise HTTPException(status_code=400, detail=\"No hay foto registrada para este usuario\")\n+\n+        logger.info(f\"üîç Face URL del usuario: {user['face_url']}\")\n+\n+        # Crear directorio temporal\n+        temp_dir = \"./temp_files\"\n+        if not os.path.exists(temp_dir):\n+            os.makedirs(temp_dir)\n+\n+        # Guardar el archivo temporal de la foto recibida\n+        with tempfile.NamedTemporaryFile(delete=False, suffix=f\"_{face_photo.filename}\") as tmp:\n+            temp_file_received = tmp.name\n+            tmp.write(content) # Escribir el contenido ya le√≠do\n+            logger.info(f\"Foto recibida guardada: {temp_file_received} ({content_size} bytes)\")\n+\n+        # Descargar la foto registrada\n+        temp_file_registered = download_image(user['face_url'])\n+        if not temp_file_registered or not os.path.exists(temp_file_registered):\n+            logger.error(f\"‚ùå No se pudo descargar o encontrar la foto registrada para {email}\")\n+            raise HTTPException(status_code=500, detail=\"Error al descargar la foto registrada\")\n+\n+        logger.info(\"üîÑ Iniciando comparaci√≥n facial...\")\n+\n+        # Realizar la comparaci√≥n facial\n+        match, similarity, exec_time = compare_faces_arcface(temp_file_received, temp_file_registered)\n+\n+        logger.info(f\"üìä Resultados de la comparaci√≥n:\")\n+        logger.info(f\"   - Coincidencia: {match}\")\n+        logger.info(f\"   - Similitud: {similarity:.2f}%\")\n+        logger.info(f\"   - Tiempo de ejecuci√≥n: {exec_time:.2f} segundos\")\n+\n+        # Limpiar archivos temporales de inmediato (antes de la verificaci√≥n 'match')\n+        # Ya usamos finally para esto, as√≠ que no es estrictamente necesario aqu√≠, pero puede ayudar a liberar espacio antes.\n+        # if os.path.exists(temp_file_received):\n+        #     os.remove(temp_file_received)\n+        # if os.path.exists(temp_file_registered):\n+        #     os.remove(temp_file_registered)\n+\n+\n+        if match:\n+            # Generar token de acceso\n+            access_token = create_access_token(data={\"sub\": email})\n+            logger.info(f\"‚úÖ Login exitoso para: {email}\")\n+            # Aseg√∫rate de que user es un diccionario y contiene los campos necesarios\n+            return LoginResponse(\n+                access_token=access_token,\n+                token_type=\"bearer\",\n+                username=user.get(\"username\"),\n+                email=user[\"email\"],\n+                voice_url=user.get(\"voice_url\"),\n+                face_url=user.get(\"face_url\")\n+            )\n+        else:\n+            logger.warning(f\"‚ùå Autenticaci√≥n facial fallida para: {email}\")\n+            raise HTTPException(\n+                status_code=401,\n+                detail=\"La autenticaci√≥n facial fall√≥. Las caras no coinciden.\"\n+            )\n+\n+    except HTTPException:\n+        raise\n+    except Exception as e:\n+        logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n+        import traceback\n+        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n+        raise HTTPException(\n+            status_code=500,\n+            detail=\"Error al procesar la autenticaci√≥n por foto\"\n+        )\n+    finally:\n+        # Limpiar archivos temporales\n+        if temp_file_received and os.path.exists(temp_file_received):\n+            try:\n+                os.remove(temp_file_received)\n+                logger.debug(f\"üßπ Archivo temporal de foto recibida eliminado: {temp_file_received}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto recibida {temp_file_received}: {str(e)}\")\n+        if temp_file_registered and os.path.exists(temp_file_registered):\n+            try:\n+                os.remove(temp_file_registered)\n+                logger.debug(f\"üßπ Archivo temporal de foto registrada eliminado: {temp_file_registered}\")\n+            except Exception as e:\n+                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal de foto registrada {temp_file_registered}: {str(e)}\")\n+\n+\n+# --- ENDPOINT CORREGIDO user_by_email ---\n+@router.get(\"/user_by_email\", response_model=UserResponseModel) # <-- Usamos el modelo Pydantic aqu√≠\n+async def user_by_email(email: str):\n+    \"\"\"\n+    Obtiene los datos b√°sicos de un usuario por su email.\n+    Retorna el ID del usuario como string.\n+    \"\"\"\n+    logger.info(f\"üì• GET /auth/user_by_email para email: {email}\")\n+    # Asumimos que mongo_client.get_user_by_email retorna un DICCIONARIO de PyMongo\n+    user_document = mongo_client.get_user_by_email(email)\n+\n+    if not user_document:\n+        logger.warning(f\"‚ùå Usuario no encontrado para email: {email}\")\n+        # FastAPI maneja esta excepci√≥n y retorna un 404\n+        raise HTTPException(status_code=404, detail=\"Usuario no encontrado\")\n+\n+    # --- EXPLICIT CONVERSION TO STRING ---\n+    # This is a fallback in case json_encoders is not working as expected\n+    if isinstance(user_document, dict) and '_id' in user_document and isinstance(user_document['_id'], ObjectId):\n+        user_document['_id'] = str(user_document['_id'])\n+        logger.debug(f\"DEBUG BACKEND: Converted ObjectId to string for _id: {user_document['_id']}\")\n+    # Note: If user_document is not a dict but some custom object, this check needs adjustment.\n+    # Assuming it's a dict based on typical PyMongo find_one results.\n+    # ------------------------------------\n+\n+\n+    logger.info(f\"‚úÖ Usuario encontrado y listo para serializar: {email}\")\n+    # Return the potentially modified dictionary\n+    # Pydantic will still validate against UserResponseModel,\n+    # but _id should now be a string, matching the 'id: str' field.\n+    return user_document\n+\n+\n+# Aseg√∫rate de que este router est√© incluido en tu aplicaci√≥n FastAPI principal\n+# En tu archivo main.py o app.py:\n+# from .auth import router as auth_router # Ajusta la importaci√≥n seg√∫n tu estructura\n+# app.include_router(auth_router, prefix=\"/auth\")\n"
                }
            ],
            "date": 1744950267809,
            "name": "Commit-0",
            "content": "from fastapi import APIRouter, HTTPException, Depends, status, UploadFile, File, Form\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi.responses import JSONResponse\nfrom datetime import timedelta\nfrom typing import Optional, Dict\nimport logging\nimport hashlib\nimport os\nfrom utils.auth_utils import create_access_token, get_current_user\nfrom mongodb_client import MongoDBClient\nfrom voice_processing import extract_embedding, compare_voices, verify_voice, preprocess_audio\nfrom azure_storage import upload_voice_recording, download_voice_recording, ensure_azure_storage, upload_face_photo\nfrom config import (\n    SECRET_KEY, \n    ACCESS_TOKEN_EXPIRE_MINUTES, \n    VOICE_SIMILARITY_THRESHOLD,\n    ENVIRONMENT,\n    IS_PRODUCTION\n)\nfrom pydantic import BaseModel\nimport librosa\nimport numpy as np\nimport face_recognition\nimport cv2\nimport time\nimport warnings\nimport onnxruntime as ort\nfrom insightface.app import FaceAnalysis\nimport contextlib\nimport io\nimport requests\nfrom urllib.parse import urlparse\nimport tempfile\n\n# Configurar logging\nlogging.basicConfig(\n    level=logging.INFO if IS_PRODUCTION else logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(),\n        logging.FileHandler('auth.log')\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n# Log del entorno actual\nlogger.info(f\"Ejecutando en entorno: {ENVIRONMENT}\")\n\nrouter = APIRouter()\nmongo_client = MongoDBClient()\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n    email: str\n    voice_url: Optional[str] = None\n\nclass LoginResponse(BaseModel):\n    access_token: str\n    token_type: str\n    username: Optional[str] = None\n    email: str\n    voice_url: Optional[str] = None\n    face_url: Optional[str] = None\n\n# Suprimir warnings molestos\nwarnings.filterwarnings(\"ignore\")\n\n# Silenciar logs internos de onnxruntime\nort.set_default_logger_severity(3)\n\n# ------------------ PREPROCESAMIENTO ------------------ #\ndef preprocess_image(image):\n    height, width = image.shape[:2]\n    max_size = 800\n    if height > max_size or width > max_size:\n        scale = max_size / max(height, width)\n        image = cv2.resize(image, (int(width * scale), int(height * scale)))\n    \n    lab = cv2.cvtColor(image, cv2.COLOR_RGB2LAB)\n    l, a, b = cv2.split(lab)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    l = clahe.apply(l)\n    lab = cv2.merge((l, a, b))\n    enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n    \n    return enhanced\n\n# ------------------ ARCFACE COMPARISON ------------------ #\ndef compare_faces_arcface(image_path1, image_path2, threshold=0.65):\n    if not os.path.exists(image_path1) or not os.path.exists(image_path2):\n        return \"One or both image files do not exist\", None, None\n\n    start_time = time.time()\n\n    img1 = cv2.imread(image_path1)\n    img2 = cv2.imread(image_path2)\n\n    if img1 is None or img2 is None:\n        return \"Error loading one or both images\", None, None\n\n    img1_rgb = cv2.cvtColor(img1, cv2.COLOR_BGR2RGB)\n    img2_rgb = cv2.cvtColor(img2, cv2.COLOR_BGR2RGB)\n\n    img1_processed = preprocess_image(img1_rgb)\n    img2_processed = preprocess_image(img2_rgb)\n\n    # Silenciar los prints del modelo durante su inicializaci√≥n\n    f = io.StringIO()\n    with contextlib.redirect_stdout(f):\n        face_analyzer = FaceAnalysis(providers=['CPUExecutionProvider'])\n        face_analyzer.prepare(ctx_id=0, det_size=(640, 640))\n\n    faces1 = face_analyzer.get(cv2.cvtColor(img1_processed, cv2.COLOR_RGB2BGR))\n    faces2 = face_analyzer.get(cv2.cvtColor(img2_processed, cv2.COLOR_RGB2BGR))\n\n    if not faces1 or not faces2:\n        return \"No faces detected in one or both images\", None, None\n\n    embedding1 = faces1[0].embedding\n    embedding2 = faces2[0].embedding\n\n    cosine_sim = np.dot(embedding1, embedding2) / (np.linalg.norm(embedding1) * np.linalg.norm(embedding2))\n    similarity_percentage = cosine_sim * 100\n    match = cosine_sim >= threshold\n\n    execution_time = time.time() - start_time\n\n    return match, similarity_percentage, execution_time\n\n# Funci√≥n para descargar imagen desde URL\ndef download_image(url):\n    try:\n        response = requests.get(url)\n        if response.status_code == 200:\n            # Crear un archivo temporal\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')\n            temp_file.write(response.content)\n            temp_file.close()\n            return temp_file.name\n        return None\n    except Exception as e:\n        logger.error(f\"Error downloading image: {str(e)}\")\n        return None\n\n@router.post(\"/register\", response_model=LoginResponse)\nasync def register(\n    email: str = Form(...),\n    username: str = Form(...),\n    password: str = Form(...),\n    voice_recording: UploadFile = File(None),\n    face_photo: UploadFile = File(None)\n):\n    try:\n        logger.info(f\"Intento de registro para: {email}\")\n\n        # Verificar si el usuario ya existe\n        existing_user = mongo_client.get_user_by_email(email)\n        if existing_user:\n            logger.warning(f\"Intento de registro con email ya existente: {email}\")\n            raise HTTPException(status_code=400, detail=\"El email ya est√° registrado\")\n\n        # Hashear la contrase√±a\n        hashed_password = hashlib.sha256(password.encode()).hexdigest()\n        logger.debug(f\"Contrase√±a hasheada para: {email}\")\n\n        # Procesar la grabaci√≥n de voz si se proporciona\n        voice_embedding = None\n        voice_embeddings = None\n        voice_url = None\n        temp_file = None\n        face_url = None\n        \n        if voice_recording:\n            logger.info(\"Procesando grabaci√≥n de voz\")\n            \n            # Verificar disponibilidad de Azure Storage si se va a subir una grabaci√≥n\n            if not await ensure_azure_storage():\n                logger.warning(\"‚ö†Ô∏è Azure Storage no est√° disponible. El usuario se registrar√° sin voz.\")\n                # No lanzamos excepci√≥n para permitir el registro sin voz\n            else:\n                # Crear directorio temporal\n                temp_dir = \"./temp_files\"\n                if not os.path.exists(temp_dir):\n                    os.makedirs(temp_dir)\n                    \n                # Guardar archivo temporalmente\n                temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n                try:\n                    with open(temp_file, \"wb\") as buffer:\n                        content = await voice_recording.read()\n                        if not content:\n                            raise HTTPException(status_code=400, detail=\"El archivo de voz est√° vac√≠o\")\n                        buffer.write(content)\n                        logger.info(f\"Archivo de voz guardado temporalmente: {temp_file}\")\n\n                    # Extraer embedding\n                    voice_embedding = extract_embedding(temp_file)\n                    if voice_embedding is None:\n                        logger.warning(\"‚ö†Ô∏è No se pudo extraer el embedding de la voz. El usuario se registrar√° sin funcionalidad de voz.\")\n                        # No falla el registro, simplemente se crea el usuario sin embedding de voz\n                    else:\n                        # Crear lista de embeddings\n                        voice_embeddings = [voice_embedding]\n                        \n                        # Subir a Azure Storage\n                        voice_url = await upload_voice_recording(temp_file, email)\n                        if not voice_url:\n                            logger.error(\"‚ùå No se pudo subir la grabaci√≥n a Azure Storage\")\n                            # Continuar sin URL de voz, pero con embedding\n                        else:\n                            logger.info(f\"üì§ Archivo subido a Azure. URL: {voice_url}\")\n                finally:\n                    # Limpiar archivo temporal\n                    if temp_file and os.path.exists(temp_file):\n                        os.remove(temp_file)\n                        logger.debug(\"üßπ Archivo temporal eliminado\")\n\n        if face_photo:\n            logger.info(\"Procesando foto de rostro\")\n            # Crear directorio temporal\n            temp_dir = \"./temp_files\"\n            if not os.path.exists(temp_dir):\n                os.makedirs(temp_dir)\n            image_file = f\"{temp_dir}/face.jpg\"\n            with open(image_file, \"wb\") as buffer:\n                content = await face_photo.read()\n                buffer.write(content)\n                logger.info(f\"Foto de rostro guardada temporalmente: {image_file}\")\n            \n            # Subir a Azure Storage\n            face_url = await upload_face_photo(image_file, email)\n            if not face_url:\n                logger.error(\"‚ùå No se pudo subir la foto de rostro a Azure Storage\")\n            else:\n                logger.info(f\"üì§ Foto de rostro subida a Azure. URL: {face_url}\")\n            \n        # Crear usuario\n        logger.info(\"Creando usuario en MongoDB\")\n        success = mongo_client.create_user(\n            username=username,\n            email=email,\n            password=hashed_password,  # Usar la contrase√±a hasheada\n            voice_embedding=voice_embedding,\n            voice_embeddings=voice_embeddings,\n            voice_url=voice_url,\n            face_url=face_url,\n        )\n\n        if success:\n            logger.info(f\"‚úÖ Usuario registrado exitosamente: {email}\")\n            # Crear token de acceso\n            access_token = create_access_token(data={\"sub\": email})\n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=username,\n                email=email,\n                voice_url=voice_url,\n                face_url=face_url,\n            )\n        else:\n            logger.error(f\"‚ùå Error al crear usuario en la base de datos: {email}\")\n            raise HTTPException(status_code=500, detail=\"Error al crear el usuario\")\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error al registrar usuario: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error en el servidor\")\n\n@router.post(\"/login\", response_model=LoginResponse)\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    \"\"\"\n    Inicia sesi√≥n con credenciales (usuario y contrase√±a)\n    \"\"\"\n    try:\n        email = form_data.username  # En OAuth2PasswordRequestForm el email se env√≠a como username\n        logger.info(f\"üîë Intento de inicio de sesi√≥n para: {email}\")\n        \n        # Hashear la contrase√±a\n        hashed_password = hashlib.sha256(form_data.password.encode()).hexdigest()\n        logger.debug(f\"Contrase√±a hasheada para login: {email}\")\n        \n        # Verificar credenciales\n        user = mongo_client.verify_user_credentials(email, hashed_password)\n        if not user:\n            logger.warning(f\"‚ùå Credenciales incorrectas para: {email}\")\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Credenciales incorrectas\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        \n        # Crear token\n        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token = create_access_token(\n            data={\"sub\": user[\"email\"]},\n            expires_delta=access_token_expires\n        )\n        \n        logger.info(f\"‚úÖ Login exitoso para: {email}\")\n        \n        return LoginResponse(\n            access_token=access_token,\n            token_type=\"bearer\",\n            username=user.get(\"username\"),\n            email=user[\"email\"],\n            voice_url=user.get(\"voice_url\")\n        )\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error en el login: {str(e)}\")\n        if isinstance(e, HTTPException):\n            raise\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error en el login: {str(e)}\"\n        )\n\n@router.post(\"/login-voice\", response_model=LoginResponse)\nasync def login_with_voice(\n    email: str = Form(...),\n    voice_recording: UploadFile = File(...)\n):\n    # Inicializar variable para evitar error de referencia\n    temp_file = None\n    \n    try:\n        logger.info(f\"üé§ Intento de login con voz para: {email}\")\n        \n        # Verificar tama√±o del archivo\n        content = await voice_recording.read()\n        if len(content) > 15 * 1024 * 1024:  # 15MB\n            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n            raise HTTPException(status_code=400, detail=\"El archivo de audio es demasiado grande (m√°ximo 15MB)\")\n            \n        if len(content) == 0:\n            logger.warning(\"‚ùå Archivo vac√≠o\")\n            raise HTTPException(status_code=400, detail=\"El archivo de audio est√° vac√≠o\")\n        \n        # Buscar usuario por email\n        user = mongo_client.get_user_by_email(email)\n        if not user:\n            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n\n        # Verificar que el usuario tenga una voz registrada\n        if not user.get('voice_url'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene voz registrada\")\n            raise HTTPException(status_code=400, detail=\"No hay voz registrada para este usuario\")\n\n        logger.info(f\"üîç Voice URL del usuario: {user['voice_url']}\")\n        \n        # Verificar si el usuario tiene embeddings de voz registrados\n        if not user.get('voice_embedding') and not user.get('voice_embeddings'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene embeddings de voz registrados\")\n            raise HTTPException(status_code=400, detail=\"No hay datos de voz registrados para este usuario\")\n            \n        # Crear directorio temporal\n        temp_dir = \"./temp_files\"\n        if not os.path.exists(temp_dir):\n            os.makedirs(temp_dir)\n            \n        # Guardar el archivo temporal de la grabaci√≥n\n        temp_file = f\"{temp_dir}/temp_{voice_recording.filename}\"\n        with open(temp_file, \"wb\") as buffer:\n            buffer.write(content)\n            logger.info(f\"üíæ Archivo de voz guardado: {temp_file} ({len(content)} bytes)\")\n        \n        # Importamos verify_voice (usando una instancia temporal del router)\n        from voice_processing import verify_voice as voice_verifier\n        \n        # Preprocesar audio y extraer embedding\n        from voice_processing import preprocess_audio, extract_embedding\n        \n        try:\n            # Preprocesar audio\n            preprocess_audio(temp_file)\n            \n            # Extraer embedding\n            input_embedding = extract_embedding(temp_file)\n            \n            if input_embedding is None:\n                raise HTTPException(\n                    status_code=400,\n                    detail=\"No se pudo procesar el audio. Intente nuevamente en un entorno m√°s silencioso.\"\n                )\n                \n            # Obtener embeddings del usuario desde MongoDB\n            user_data = mongo_client.get_user_voice_data(email)\n            \n            # Verificar contra m√∫ltiples embeddings y tomar el mejor resultado\n            best_similarity = 0\n            is_match = False\n            \n            # Verificar contra la galer√≠a de embeddings si existe\n            for stored_embedding in user_data.get('voice_embeddings', []):\n                from voice_processing import compare_voices\n                result = compare_voices(input_embedding, stored_embedding)\n                if result[\"similarity\"] > best_similarity:\n                    best_similarity = result[\"similarity\"]\n                    is_match = result[\"match\"]\n                    \n            # Si no hay galer√≠a, verificar con el embedding principal\n            if not user_data.get('voice_embeddings') and user_data.get('voice_embedding'):\n                from voice_processing import compare_voices\n                result = compare_voices(input_embedding, user_data['voice_embedding'])\n                best_similarity = result[\"similarity\"]\n                is_match = result[\"match\"]\n            \n            # Verificar si la voz coincide\n            if not is_match:\n                logger.warning(f\"‚ùå Similitud insuficiente: {best_similarity:.2f} < {VOICE_SIMILARITY_THRESHOLD}\")\n                raise HTTPException(status_code=401, detail=\"La voz no coincide\")\n            \n            # Si llegamos aqu√≠, la voz coincide\n            logger.info(f\"‚úÖ Login exitoso para {email} con similitud {best_similarity:.2f}\")\n            \n            # Crear token\n            access_token = create_access_token(data={\"sub\": email})\n            \n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=user.get(\"username\"),\n                email=email,\n                voice_url=user.get(\"voice_url\")\n            )\n            \n        except HTTPException:\n            raise\n        except Exception as e:\n            logger.error(f\"‚ùå Error al procesar la voz: {str(e)}\")\n            raise HTTPException(\n                status_code=500,\n                detail=\"Error al procesar la voz\"\n            )\n\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error en login con voz: {str(e)}\")\n        import traceback\n        logger.error(f\"Stack trace: {traceback.format_exc()}\")\n        raise HTTPException(\n            status_code=500,\n            detail=\"Error al procesar la autenticaci√≥n por voz\"\n        )\n    finally:\n        # Limpiar archivos temporales\n        if temp_file and os.path.exists(temp_file):\n            try:\n                os.remove(temp_file)\n                logger.debug(\"üßπ Archivo temporal eliminado\")\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è No se pudo eliminar archivo temporal: {str(e)}\")\n\n@router.get(\"/me\", response_model=LoginResponse)\nasync def read_users_me(current_user: dict = Depends(get_current_user)):\n    return LoginResponse(\n        access_token=\"\",\n        token_type=\"bearer\",\n        username=current_user.get(\"username\"),\n        email=current_user[\"email\"],\n        voice_url=current_user.get(\"voice_url\")\n    )\n\n@router.post(\"/login_face\", response_model=LoginResponse)\nasync def login_face(\n    email: str = Form(...),\n    face_photo: UploadFile = File(...)\n):\n    try:\n        logger.info(f\"üì∏ Intento de login con foto para: {email}\")\n        \n        # Verificar tama√±o del archivo\n        content = await face_photo.read()\n        if len(content) > 5 * 1024 * 1024:  # 5MB\n            logger.warning(f\"‚ùå Archivo demasiado grande: {len(content)} bytes\")\n            raise HTTPException(status_code=400, detail=\"La foto es demasiado grande (m√°ximo 5MB)\")\n            \n        if len(content) == 0:\n            logger.warning(\"‚ùå Archivo vac√≠o\")\n            raise HTTPException(status_code=400, detail=\"La foto est√° vac√≠a\")\n        \n        # Buscar usuario por email\n        user = mongo_client.get_user_by_email(email)\n        if not user:\n            logger.warning(f\"‚ùå Usuario no encontrado: {email}\")\n            raise HTTPException(status_code=401, detail=\"Credenciales inv√°lidas\")\n\n        # Verificar que el usuario tenga una foto registrada\n        if not user.get('face_url'):\n            logger.warning(f\"‚ö†Ô∏è Usuario {email} no tiene foto registrada\")\n            raise HTTPException(status_code=400, detail=\"No hay foto registrada para este usuario\")\n\n        logger.info(f\"üîç Face URL del usuario: {user['face_url']}\")\n        \n        # Crear directorio temporal\n        temp_dir = \"./temp_files\"\n        if not os.path.exists(temp_dir):\n            os.makedirs(temp_dir)\n            \n        # Guardar el archivo temporal de la foto recibida\n        temp_file_received = f\"{temp_dir}/temp_{face_photo.filename}\"\n        with open(temp_file_received, \"wb\") as buffer:\n            buffer.write(content)\n            logger.info(f\"üíæ Foto recibida guardada: {temp_file_received} ({len(content)} bytes)\")\n\n        # Descargar la foto registrada\n        temp_file_registered = download_image(user['face_url'])\n        if not temp_file_registered:\n            raise HTTPException(status_code=500, detail=\"Error al descargar la foto registrada\")\n\n        logger.info(\"üîÑ Iniciando comparaci√≥n facial...\")\n        \n        # Realizar la comparaci√≥n facial\n        match, similarity, exec_time = compare_faces_arcface(temp_file_received, temp_file_registered)\n        \n        logger.info(f\"üìä Resultados de la comparaci√≥n:\")\n        logger.info(f\"   - Coincidencia: {match}\")\n        logger.info(f\"   - Similitud: {similarity:.2f}%\")\n        logger.info(f\"   - Tiempo de ejecuci√≥n: {exec_time:.2f} segundos\")\n\n        # Limpiar archivos temporales\n        if os.path.exists(temp_file_received):\n            os.remove(temp_file_received)\n        if os.path.exists(temp_file_registered):\n            os.remove(temp_file_registered)\n            \n        if match:\n            # Generar token de acceso\n            access_token = create_access_token(data={\"sub\": email})\n            logger.info(f\"‚úÖ Login exitoso para: {email}\")\n            return LoginResponse(\n                access_token=access_token,\n                token_type=\"bearer\",\n                username=user.get(\"username\"),\n                email=email,\n                voice_url=user.get(\"voice_url\"),\n                face_url=user.get(\"face_url\")\n            )\n        else:\n            logger.warning(f\"‚ùå Autenticaci√≥n facial fallida para: {email}\")\n            raise HTTPException(\n                status_code=401,\n                detail=\"La autenticaci√≥n facial fall√≥. Las caras no coinciden.\"\n            )\n            \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error en login con foto: {str(e)}\")\n        raise HTTPException(\n            status_code=500,\n            detail=\"Error al procesar la autenticaci√≥n por foto\"\n        ) "
        }
    ]
}